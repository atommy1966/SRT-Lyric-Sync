<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' https://aistudiocdn.com https://cdn.tailwindcss.com https://plausible.io data:; style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://fonts.googleapis.com; font-src https://fonts.gstatic.com; connect-src 'self' https://generativelanguage.googleapis.com https://aistudiocdn.com https://plausible.io;">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SRT Subtitle Sync - AI Subtitle Generator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 256 256' fill='none'><rect width='256' height='256' rx='32' fill='url(%23gradient)'/><defs><linearGradient id='gradient' x1='0' y1='0' x2='256' y2='256' gradientUnits='userSpaceOnUse'><stop stop-color='%2314B8A6'/><stop offset='1' stop-color='%2306B6D4'/></linearGradient></defs><path d='M128 72V158.5C128 152.28 124.512 146.96 119.24 144.4C113.968 141.84 107.696 142.44 102.92 145.96C98.144 149.48 95.504 155.4 96.224 161.44C96.944 167.48 100.88 172.56 106.4 174.52C111.92 176.48 117.968 175.08 122.24 171.04C126.512 167 128 161.2 128 155.5M160 56V142.5C160 136.28 156.512 130.96 151.24 128.4C145.968 125.84 139.696 126.44 134.92 129.96C130.144 133.48 127.504 139.4 128.224 145.44C128.944 151.48 132.88 156.56 138.4 158.52C143.92 160.48 149.968 159.08 154.24 155.04C158.512 151 160 145.2 160 139.5' stroke='white' stroke-width='12' stroke-linecap='round' stroke-linejoin='round'/><line x1='128' y1='72' x2='160' y2='56' stroke='white' stroke-width='12' stroke-linecap='round'/><path d='M192 104C192 81.9086 174.091 64 152 64C136.83 64 123.593 71.8034 115.635 83.635M115.635 83.635L122 92M115.635 83.635L106.365 80.365' stroke='white' stroke-opacity='0.8' stroke-width='10' stroke-linecap='round' stroke-linejoin='round'/><path d='M64 152C64 174.091 81.9086 192 104 192C119.17 192 132.407 184.197 140.365 172.365M140.365 172.365L134 164M140.365 172.365L149.635 175.635' stroke='white' stroke-opacity='0.8' stroke-width='10' stroke-linecap='round' stroke-linejoin='round'/></svg>" type="image/svg+xml" />
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Create perfectly synchronized subtitles with AI. SRT Subtitle Sync automatically transcribes or syncs your text to video/audio. Supports SRT, VTT, LRC formats. Free online tool." />
    <meta name="keywords" content="SRT sync, lyric sync, subtitle generator, AI subtitles, VTT creator, LRC generator, video subtitles, audio transcription, lyric synchronization, synchronize lyrics, AI transcription, 歌詞同期, 字幕作成, AI字幕" />
    <link rel="canonical" href="https://srt-lyric-sync-369376059789.us-west1.run.app/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://srt-lyric-sync-369376059789.us-west1.run.app/" />
    <meta property="og:title" content="SRT Subtitle Sync - AI Subtitle Generator" />
    <meta property="og:description" content="Create perfectly synchronized subtitles with AI. Automatically transcribes or syncs text to video/audio. Supports SRT, VTT, LRC formats." />
    <meta property="og:image" content="https://raw.githubusercontent.com/atommy1966/SRT-Lyric-Sync-assets/main/2025-09-14%209.32.26.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://srt-lyric-sync-369376059789.us-west1.run.app/" />
    <meta property="twitter:title" content="SRT Subtitle Sync - AI Subtitle Generator" />
    <meta property="twitter:description" content="Create perfectly synchronized subtitles with AI. Automatically transcribes or syncs text to video/audio. Supports SRT, VTT, LRC formats." />
    <meta property="twitter:image" content="https://raw.githubusercontent.com/atommy1966/SRT-Lyric-Sync-assets/main/2025-09-14%209.32.26.png" />
    
    <!-- Performance Optimization: Preconnect to font domains -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Performance Optimization: Asynchronously load Google Fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Google+Sans+Text:wght@400;500;700&display=swap" media="print" onload="this.media='all'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Google+Sans+Text:wght@400;500;700&display=swap"></noscript>

    <!-- Load and configure Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Google Sans Text', 'sans-serif'],
            },
          }
        }
      }
    </script>

    <script defer data-domain="srt-lyric-sync-369376059789.us-west1.run.app" src="https://plausible.io/js/script.file-downloads.hash.outbound-links.pageview-props.revenue.tagged-events.js"></script>
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.1.1/client",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.18.0"
  }
}
</script>
<style>
  /* Custom styles for video subtitles to ensure they wrap correctly */
  video::cue {
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    /* Use a responsive font size based on the smaller viewport dimension */
    font-size: 2.5vmin;
    /* Respect newlines and allow wrapping */
    white-space: pre-line;
    line-height: 1.3;
    /* Add a shadow for better readability on any background */
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
  }

  /* Increase font size on smaller screens for better readability */
  @media (max-width: 768px) {
    video::cue {
      font-size: 4.5vmin;
      line-height: 1.4;
    }
  }
</style>
<meta name="google-site-verification" content="RNLIziuxWmOlY8NwLaJDnRN9us7o2c1uTI_7IrPic3Y" />
<!-- JSON-LD Structured Data -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "SRT Subtitle Sync",
  "applicationCategory": "MultimediaApplication",
  "operatingSystem": "Any",
  "description": "An AI-powered web application to automatically generate and edit synchronized subtitle files (SRT, VTT, LRC) from video or audio. Features include one-click transcription, high-precision timing refinement, and an advanced interactive editor.",
  "url": "https://srt-lyric-sync-369376059789.us-west1.run.app/",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  }
}
</script>
</head>
  <body class="bg-gray-900 text-white font-sans">
    <div id="root"></div>
    <script type="module">
      import React, { useState, useCallback, useEffect, useRef, useImperativeHandle, forwardRef, useLayoutEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI, Type } from "@google/genai";

      // --- Start of inlined files ---
      
      // ** i18n/config.ts **
      const supportedLanguages = [
        { code: 'en', name: 'English' },
        { code: 'ja', name: '日本語' },
        { code: 'es', name: 'Español' },
        { code: 'zh-CN', name: '简体中文' }
      ];

      const translations = {
        en: {
          appTitle: "SRT Subtitle Sync",
          appSubtitle: "AI-powered subtitle synchronization",
          appDescriptionTooltip: "This tool uses AI to synchronize text with an audio or video file, creating subtitle files (SRT, VTT, LRC). You can either provide the text or have the AI transcribe it for you.",
          languageSelectorLabel: "Select Language",
          clearSession: "Clear Session",
          clearSessionConfirm: "Are you sure you want to clear all data and start over?",
          draftFound: "Found an unsaved draft",
          draftForFile: " for \"{fileName}\"",
          draftQuery: ". Would you like to restore it?",
          draftRestore: "Restore",
          draftDismiss: "Dismiss",
          uploadHeader: "1. Upload Video or Audio",
          previewHeaderAudio: "1. Preview Audio",
          previewHeaderVideo: "1. Preview Video",
          uploadTooltip: "Upload your video (MP4, MOV) or audio (MP3, WAV) file. Max size: 15MB. The file is processed in your browser and is not uploaded to any server for storage.",
          lyricsHeader: "2. Provide Text",
          lyricsTooltip: "1) Paste text directly. 2) Import a text file (.txt) or subtitle file (.srt, .vtt, .lrc). 3) Click 'Transcribe' to let AI generate text and subtitles from your video/audio file in one go.",
          editorHeader: "3. Edit Your Subtitles",
          editorTooltip: "Review and edit your subtitles. Click on a subtitle to jump to that time in the video. Use the tools to refine timings, translate, adjust global offsets, or download the final file.",
          clickToUpload: "Click to upload",
          dragAndDrop: " or drag and drop",
          fileTypes: "Video (MP4, MOV) or Audio (MP3, WAV)",
          maxFileSize: "Max file size: {size}MB",
          removeMedia: "Remove",
          lyricsPlaceholder: "Paste text here, import a subtitle file (.srt, .vtt, .lrc), or click 'Transcribe'...",
          pasteFromClipboard: "Paste",
          copied: "Copied!",
          copyLyrics: "Copy text",
          clearLyrics: "Clear text",
          import: "Import",
          importActive: "Importing...",
          importTooltip: "Import subtitles from a file (.srt, .vtt, .lrc, .txt)",
          transcribe: "Transcribe",
          transcribeTooltip: "Transcribe audio and generate subtitles in one step.",
          transcribeActive: "Processing...",
          transcribeDisabledTooltip: "Upload a video/audio file to enable transcription.",
          generate: "Generate",
          generateTooltip: "Generate synchronized subtitles from your text and video/audio file.",
          generateActive: "Generating...",
          generateDisabledTooltip: "Upload a video/audio file and provide text to enable.",
          undo: "Undo",
          redo: "Redo",
          languageSelectLabelDropdown: "Select language to translate to",
          translate: "Translate",
          translateActive: "Translating...",
          translateTooltip: "Translate to {language}",
          refine: "Refine",
          refineTooltip: "Use AI to improve timing accuracy",
          downloadSRT: "Download SRT",
          downloadSRTTooltip: "Download SRT file",
          moreDownloads: "More download options",
          downloadVTT: "Download VTT",
          downloadLRC: "Download LRC",
          globalOffset: "Global Timing Offset",
          globalOffsetTooltip: "Shift all subtitle timestamps forward or backward simultaneously.",
          vocalDecay: "Vocal Decay Helper (End Time Padding)",
          vocalDecayTooltip: "Adds a small delay to the end of each subtitle to account for vocal decay.",
          resetOffset: "Reset offset",
          resetPadding: "Reset padding",
          setTimeToCurrent: "Set to video's current time",
          splitLine: "Split Line",
          splitLineTooltip: "Split subtitle at cursor position",
          dragToReorder: "Drag to reorder",
          moveUp: "Move Up",
          moveDown: "Move Down",
          insertLineBelow: "Insert Line Below",
          mergeWithNext: "Merge with Next",
          delete: "Delete",
          play: "Play",
          pause: "Pause",
          mute: "Mute",
          unmute: "Unmute",
          volume: "Volume",
          toggleFullscreen: "Toggle Fullscreen",
          loadingRefining: "Refining timings...",
          loadingTranscribingStep1: "Step 1/3: Transcribing audio...",
          loadingTranscribingStep2: "Step 2/3: Analyzing audio & syncing text...",
          loadingTranscribingStep3: "Step 3/3: Refining timings for accuracy...",
          loadingGeneratingStep1: "Step 1/2: Analyzing audio & syncing text...",
          loadingGeneratingStep2: "Step 2/2: Refining timings for accuracy...",
          loadingGeneric: "This may take a few minutes for longer videos.",
          placeholder: "Your generated SRT file will appear here.",
          mediaMissing: "Video/Audio File Missing",
          mediaMissingDescription: "Please re-upload the original video/audio file to edit and preview the subtitles.",
          errorGeneric: "An unexpected error occurred.",
          errorFailedToProcess: "Failed to process: {error}",
          errorApiKeyMissing: "Application is not configured correctly. The API_KEY is missing. Please contact the administrator.",
          errorFileTooLarge: "File is too large. Please select a file smaller than {size}MB.",
          errorNoSubtitlesToRefine: "There are no subtitles to refine.",
          errorNoSubtitlesToTranslate: "There are no subtitles to translate.",
          errorMediaNeededForRefine: "Please upload the video/audio file to use the refine feature.",
          errorMediaNeededForGenerate: "Please upload a video/audio file before generating subtitles.",
          errorMediaNeededForTranscribe: "Please upload a video/audio file before transcribing.",
          errorLyricsNeededForGenerate: "Text is empty. Please provide text to generate subtitles.",
          errorFailedToParseFile: "Failed to parse file: {error}",
          errorFileEmpty: "File is empty or could not be read.",
          errorUnsupportedFileType: "Unsupported file type: .{extension}",
          errorNoEntriesFound: "No valid subtitle entries found in the file.",
          errorPasteBlocked: "Pasting with the button was blocked by your browser.\n\nThis is a common security measure in modern web browsers, especially in secure environments.\n\nPlease paste directly into the text area using your keyboard (Ctrl+V or Cmd+V).",
          draftRestored: "Draft restored. Please re-upload the original video/audio file to use the preview and refine functions.",
          detectedFormatLoad: "Detected {format} format. Click to load into editor.",
          poweredBy: "Powered by Google Gemini",
        },
        ja: {
          appTitle: "SRT字幕シンク",
          appSubtitle: "AIによる字幕同期ツール",
          appDescriptionTooltip: "このツールはAIを使い、テキストを音声・動画ファイルと同期させ、字幕ファイル（SRT, VTT, LRC）を作成します。テキストを直接入力するか、AIに文字起こしさせることも可能です。",
          languageSelectorLabel: "言語を選択",
          clearSession: "セッションをクリア",
          clearSessionConfirm: "すべてのデータを消去して最初からやり直しますか？",
          draftFound: "未保存の下書きが見つかりました",
          draftForFile: "（ファイル名: \"{fileName}\"）",
          draftQuery: "。復元しますか？",
          draftRestore: "復元",
          draftDismiss: "破棄",
          uploadHeader: "1. 動画または音声をアップロード",
          previewHeaderAudio: "1. 音声をプレビュー",
          previewHeaderVideo: "1. 動画をプレビュー",
          uploadTooltip: "動画（MP4, MOV）または音声（MP3, WAV）ファイルをアップロードしてください。最大サイズ: 15MB。ファイルはブラウザ内で処理され、サーバーには保存されません。",
          lyricsHeader: "2. テキストを入力",
          lyricsTooltip: "1) テキストを直接貼り付け。 2) テキストファイル（.txt）または字幕ファイル（.srt, .vtt, .lrc）をインポート。 3)「文字起こし」をクリックすると、AIが動画/音声ファイルからテキストと字幕を一度に生成します。",
          editorHeader: "3. 字幕を編集",
          editorTooltip: "字幕を確認・編集します。字幕をクリックすると、動画のその時間にジャンプします。ツールを使ってタイミングの調整、翻訳、全体的なオフセットの変更、最終ファイルのダウンロードができます。",
          clickToUpload: "クリックしてアップロード",
          dragAndDrop: "またはドラッグ＆ドロップ",
          fileTypes: "動画 (MP4, MOV) または 音声 (MP3, WAV)",
          maxFileSize: "最大ファイルサイズ: {size}MB",
          removeMedia: "削除",
          lyricsPlaceholder: "ここにテキストを貼り付けるか、字幕ファイル(.srt, .vtt, .lrc)をインポートするか、「文字起こし」をクリックしてください...",
          pasteFromClipboard: "貼り付け",
          copied: "コピーしました！",
          copyLyrics: "テキストをコピー",
          clearLyrics: "テキストを消去",
          import: "インポート",
          importActive: "インポート中...",
          importTooltip: "ファイルから字幕をインポート (.srt, .vtt, .lrc, .txt)",
          transcribe: "文字起こし",
          transcribeTooltip: "音声を文字起こしし、字幕を一度に生成します。",
          transcribeActive: "処理中...",
          transcribeDisabledTooltip: "動画/音声ファイルをアップロードすると有効になります。",
          generate: "生成",
          generateTooltip: "テキストと動画/音声ファイルから同期した字幕を生成します。",
          generateActive: "生成中...",
          generateDisabledTooltip: "動画/音声ファイルをアップロードし、テキストを入力すると有効になります。",
          undo: "元に戻す",
          redo: "やり直し",
          languageSelectLabelDropdown: "翻訳する言語を選択",
          translate: "翻訳",
          translateActive: "翻訳中...",
          translateTooltip: "{language}に翻訳",
          refine: "リファイン",
          refineTooltip: "AIを使ってタイミングの精度を向上させます",
          downloadSRT: "SRTをダウンロード",
          downloadSRTTooltip: "SRTファイルをダウンロード",
          moreDownloads: "その他の形式",
          downloadVTT: "VTTをダウンロード",
          downloadLRC: "LRCをダウンロード",
          globalOffset: "グローバルタイミングオフセット",
          globalOffsetTooltip: "すべての字幕のタイムスタンプを同時に前後にずらします。",
          vocalDecay: "ボーカル減衰ヘルパー（終了時間補正）",
          vocalDecayTooltip: "各字幕の終わりに短い遅延を追加し、声の余韻を表現します。",
          resetOffset: "オフセットをリセット",
          resetPadding: "補正をリセット",
          setTimeToCurrent: "動画の現在時間に設定",
          splitLine: "行を分割",
          splitLineTooltip: "カーソル位置で字幕を分割します",
          dragToReorder: "ドラッグして並べ替え",
          moveUp: "上に移動",
          moveDown: "下に移動",
          insertLineBelow: "下に行を挿入",
          mergeWithNext: "次と結合",
          delete: "削除",
          play: "再生",
          pause: "一時停止",
          mute: "ミュート",
          unmute: "ミュート解除",
          volume: "音量",
          toggleFullscreen: "全画面表示の切り替え",
          loadingRefining: "タイミングを調整中...",
          loadingTranscribingStep1: "ステップ1/3: 音声を文字起こし中...",
          loadingTranscribingStep2: "ステップ2/3: 音声を分析し、テキストを同期中...",
          loadingTranscribingStep3: "ステップ3/3: タイミングの精度を向上中...",
          loadingGeneratingStep1: "ステップ1/2: 音声を分析し、テキストを同期中...",
          loadingGeneratingStep2: "ステップ2/2: タイミングの精度を向上中...",
          loadingGeneric: "長い動画の場合、数分かかることがあります。",
          placeholder: "生成されたSRTファイルはここに表示されます。",
          mediaMissing: "動画/音声ファイルがありません",
          mediaMissingDescription: "字幕を編集・プレビューするには、元の動画/音声ファイルを再アップロードしてください。",
          errorGeneric: "予期せぬエラーが発生しました。",
          errorFailedToProcess: "処理に失敗しました: {error}",
          errorApiKeyMissing: "アプリケーションが正しく設定されていません。API_KEYが見つかりません。管理者にお問い合わせください。",
          errorFileTooLarge: "ファイルが大きすぎます。{size}MB未満のファイルを選択してください。",
          errorNoSubtitlesToRefine: "リファインする字幕がありません。",
          errorNoSubtitlesToTranslate: "翻訳する字幕がありません。",
          errorMediaNeededForRefine: "リファイン機能を使うには動画/音声ファイルをアップロードしてください。",
          errorMediaNeededForGenerate: "字幕を生成する前に動画/音声ファイルをアップロードしてください。",
          errorMediaNeededForTranscribe: "文字起こしをする前に動画/音声ファイルをアップロードしてください。",
          errorLyricsNeededForGenerate: "テキストが空です。字幕を生成するにはテキストを入力してください。",
          errorFailedToParseFile: "ファイルの解析に失敗しました: {error}",
          errorFileEmpty: "ファイルが空か、読み込めませんでした。",
          errorUnsupportedFileType: "サポートされていないファイル形式です: .{extension}",
          errorNoEntriesFound: "ファイル内に有効な字幕が見つかりませんでした。",
          errorPasteBlocked: "ブラウザのセキュリティ設定により、ボタンでの貼り付けがブロックされました。\n\nキーボードのショートカット（Ctrl+V または Cmd+V）を使って直接テキストエリアに貼り付けてください。",
          draftRestored: "下書きを復元しました。プレビューやリファイン機能を使うには、元の動画/音声ファイルを再アップロードしてください。",
          detectedFormatLoad: "「{format}」形式を検出しました。クリックしてエディタに読み込みます。",
          poweredBy: "Powered by Google Gemini",
        },
        es: {
          appTitle: "SRT Subtitle Sync",
          appSubtitle: "Sincronización de subtítulos con IA",
          appDescriptionTooltip: "Esta herramienta utiliza IA para sincronizar texto con un archivo de audio o video, creando archivos de subtítulos (SRT, VTT, LRC). Puedes proporcionar el texto o dejar que la IA lo transcriba por ti.",
          languageSelectorLabel: "Seleccionar Idioma",
          clearSession: "Limpiar Sesión",
          clearSessionConfirm: "¿Estás seguro de que quieres borrar todos los datos y empezar de nuevo?",
          draftFound: "Se encontró un borrador no guardado",
          draftForFile: " para \"{fileName}\"",
          draftQuery: ". ¿Te gustaría restaurarlo?",
          draftRestore: "Restaurar",
          draftDismiss: "Descartar",
          uploadHeader: "1. Subir Video o Audio",
          previewHeaderAudio: "1. Vista Previa de Audio",
          previewHeaderVideo: "1. Vista Previa de Video",
          uploadTooltip: "Sube tu archivo de video (MP4, MOV) o audio (MP3, WAV). Tamaño máximo: 15MB. El archivo se procesa en tu navegador y no se sube a ningún servidor.",
          lyricsHeader: "2. Proporcionar Texto",
          lyricsTooltip: "1) Pega el texto directamente. 2) Importa un archivo de texto (.txt) o de subtítulos (.srt, .vtt, .lrc). 3) Haz clic en 'Transcribir' para que la IA genere el texto y los subtítulos a partir de tu archivo de video/audio de una sola vez.",
          editorHeader: "3. Editar Tus Subtítulos",
          editorTooltip: "Revisa y edita tus subtítulos. Haz clic en un subtítulo para saltar a ese momento en el video. Usa las herramientas para refinar tiempos, traducir, ajustar desplazamientos globales o descargar el archivo final.",
          clickToUpload: "Haz clic para subir",
          dragAndDrop: " o arrastra y suelta",
          fileTypes: "Video (MP4, MOV) o Audio (MP3, WAV)",
          maxFileSize: "Tamaño máx. de archivo: {size}MB",
          removeMedia: "Quitar",
          lyricsPlaceholder: "Pega el texto aquí, importa un archivo de subtítulos (.srt, .vtt, .lrc) o haz clic en 'Transcribir'...",
          pasteFromClipboard: "Pegar",
          copied: "¡Copiado!",
          copyLyrics: "Copiar texto",
          clearLyrics: "Limpiar texto",
          import: "Importar",
          importActive: "Importando...",
          importTooltip: "Importar subtítulos desde un archivo (.srt, .vtt, .lrc, .txt)",
          transcribe: "Transcribir",
          transcribeTooltip: "Transcribe el audio y genera subtítulos en un solo paso.",
          transcribeActive: "Procesando...",
          transcribeDisabledTooltip: "Sube un archivo de video/audio para habilitar la transcripción.",
          generate: "Generar",
          generateTooltip: "Genera subtítulos sincronizados a partir de tu texto y archivo de video/audio.",
          generateActive: "Generando...",
          generateDisabledTooltip: "Sube un archivo de video/audio y proporciona el texto para habilitar.",
          undo: "Deshacer",
          redo: "Rehacer",
          languageSelectLabelDropdown: "Seleccionar idioma para traducir",
          translate: "Traducir",
          translateActive: "Traduciendo...",
          translateTooltip: "Traducir a {language}",
          refine: "Refinar",
          refineTooltip: "Usa IA para mejorar la precisión de los tiempos",
          downloadSRT: "Descargar SRT",
          downloadSRTTooltip: "Descargar archivo SRT",
          moreDownloads: "Más opciones",
          downloadVTT: "Descargar VTT",
          downloadLRC: "Descargar LRC",
          globalOffset: "Desplazamiento Global de Tiempo",
          globalOffsetTooltip: "Desplaza todos los tiempos de los subtítulos hacia adelante o atrás simultáneamente.",
          vocalDecay: "Ayudante de Decaimiento Vocal (Relleno Final)",
          vocalDecayTooltip: "Añade un pequeño retardo al final de cada subtítulo para reflejar el desvanecimiento de la voz.",
          resetOffset: "Reiniciar desplazamiento",
          resetPadding: "Reiniciar relleno",
          setTimeToCurrent: "Ajustar a tiempo actual del video",
          splitLine: "Dividir Línea",
          splitLineTooltip: "Divide el subtítulo en la posición del cursor",
          dragToReorder: "Arrastra para reordenar",
          moveUp: "Mover Arriba",
          moveDown: "Mover Abajo",
          insertLineBelow: "Insertar Línea Debajo",
          mergeWithNext: "Fusionar con Siguiente",
          delete: "Eliminar",
          play: "Reproducir",
          pause: "Pausa",
          mute: "Silenciar",
          unmute: "Activar sonido",
          volume: "Volumen",
          toggleFullscreen: "Pantalla Completa",
          loadingRefining: "Refinando tiempos...",
          loadingTranscribingStep1: "Paso 1/3: Transcribiendo audio...",
          loadingTranscribingStep2: "Paso 2/3: Analizando audio y sincronizando texto...",
          loadingTranscribingStep3: "Paso 3/3: Refinando precisión de tiempos...",
          loadingGeneratingStep1: "Paso 1/2: Analizando audio y sincronizando texto...",
          loadingGeneratingStep2: "Paso 2/2: Refinando precisión de tiempos...",
          loadingGeneric: "Esto puede tardar unos minutos para videos más largos.",
          placeholder: "Tu archivo SRT generado aparecerá aquí.",
          mediaMissing: "Falta el Archivo de Video/Audio",
          mediaMissingDescription: "Por favor, vuelve a subir el archivo de video/audio original para editar y previsualizar los subtítulos.",
          errorGeneric: "Ocurrió un error inesperado.",
          errorFailedToProcess: "Fallo al procesar: {error}",
          errorApiKeyMissing: "La aplicación no está configurada correctamente. Falta la API_KEY. Por favor, contacte al administrador.",
          errorFileTooLarge: "El archivo es demasiado grande. Por favor, selecciona un archivo de menos de {size}MB.",
          errorNoSubtitlesToRefine: "No hay subtítulos para refinar.",
          errorNoSubtitlesToTranslate: "No hay subtítulos para traducir.",
          errorMediaNeededForRefine: "Por favor, sube el archivo de video/audio para usar la función de refinar.",
          errorMediaNeededForGenerate: "Por favor, sube un archivo de video/audio antes de generar subtítulos.",
          errorMediaNeededForTranscribe: "Por favor, sube un archivo de video/audio antes de transcribir.",
          errorLyricsNeededForGenerate: "El texto está vacío. Por favor, proporciona el texto para generar subtítulos.",
          errorFailedToParseFile: "Fallo al analizar el archivo: {error}",
          errorFileEmpty: "El archivo está vacío o no se pudo leer.",
          errorUnsupportedFileType: "Tipo de archivo no soportado: .{extension}",
          errorNoEntriesFound: "No se encontraron entradas de subtítulos válidas en el archivo.",
          errorPasteBlocked: "El pegado con el botón fue bloqueado por tu navegador.\n\nEsta es una medida de seguridad común en los navegadores web modernos.\n\nPor favor, pega directamente en el área de texto usando tu teclado (Ctrl+V o Cmd+V).",
          draftRestored: "Borrador restaurado. Por favor, vuelve a subir el archivo de video/audio original para usar las funciones de vista previa y refinado.",
          detectedFormatLoad: "Formato {format} detectado. Haz clic para cargar en el editor.",
          poweredBy: "Desarrollado con Google Gemini",
        },
        'zh-CN': {
          appTitle: "SRT 字幕同步",
          appSubtitle: "AI 驱动的字幕同步工具",
          appDescriptionTooltip: "本工具使用 AI 将文本与音频或视频文件同步，创建字幕文件（SRT、VTT、LRC）。您可以提供文本，也可以让 AI 为您转录。",
          languageSelectorLabel: "选择语言",
          clearSession: "清除会话",
          clearSessionConfirm: "您确定要清除所有数据并重新开始吗？",
          draftFound: "发现未保存的草稿",
          draftForFile: "（文件名：“{fileName}”）",
          draftQuery: "。您想恢复它吗？",
          draftRestore: "恢复",
          draftDismiss: "放弃",
          uploadHeader: "1. 上传视频或音频",
          previewHeaderAudio: "1. 预览音频",
          previewHeaderVideo: "1. 预览视频",
          uploadTooltip: "上传您的视频（MP4, MOV）或音频（MP3, WAV）文件。最大大小：15MB。文件在您的浏览器中处理，不会上传到任何服务器存储。",
          lyricsHeader: "2. 提供文本",
          lyricsTooltip: "1) 直接粘贴文本。 2) 导入文本文件 (.txt) 或字幕文件 (.srt, .vtt, .lrc)。 3) 点击“转录”，让 AI 从您的视频/音频文件一步生成文本和字幕。",
          editorHeader: "3. 编辑您的字幕",
          editorTooltip: "检查和编辑您的字幕。点击字幕可跳转到视频中的相应时间。使用工具微调时间、翻译、调整全局偏移或下载最终文件。",
          clickToUpload: "点击上传",
          dragAndDrop: "或拖放文件",
          fileTypes: "视频 (MP4, MOV) 或音频 (MP3, WAV)",
          maxFileSize: "最大文件大小：{size}MB",
          removeMedia: "移除",
          lyricsPlaceholder: "在此处粘贴文本、导入字幕文件 (.srt, .vtt, .lrc)，或点击“转录”...",
          pasteFromClipboard: "粘贴",
          copied: "已复制！",
          copyLyrics: "复制文本",
          clearLyrics: "清除文本",
          import: "导入",
          importActive: "导入中...",
          importTooltip: "从文件导入字幕 (.srt, .vtt, .lrc, .txt)",
          transcribe: "转录",
          transcribeTooltip: "一步完成音频转录和字幕生成。",
          transcribeActive: "处理中...",
          transcribeDisabledTooltip: "上传视频/音频文件以启用转录。",
          generate: "生成",
          generateTooltip: "从您的文本和视频/音频文件生成同步字幕。",
          generateActive: "生成中...",
          generateDisabledTooltip: "上传视频/音频文件并提供文本以启用。",
          undo: "撤销",
          redo: "重做",
          languageSelectLabelDropdown: "选择要翻译的语言",
          translate: "翻译",
          translateActive: "翻译中...",
          translateTooltip: "翻译成 {language}",
          refine: "微调",
          refineTooltip: "使用 AI 提高时间精度",
          downloadSRT: "下载 SRT",
          downloadSRTTooltip: "下载 SRT 文件",
          moreDownloads: "更多下载选项",
          downloadVTT: "下载 VTT",
          downloadLRC: "下载 LRC",
          globalOffset: "全局时间偏移",
          globalOffsetTooltip: "同时向前或向后移动所有字幕时间戳。",
          vocalDecay: "人声衰减助手 (结束时间填充)",
          vocalDecayTooltip: "为每个字幕的结尾添加少量延迟，以适应人声的自然衰减。",
          resetOffset: "重置偏移",
          resetPadding: "重置填充",
          setTimeToCurrent: "设置为视频当前时间",
          splitLine: "拆分行",
          splitLineTooltip: "在光标位置拆分字幕",
          dragToReorder: "拖动以重新排序",
          moveUp: "上移",
          moveDown: "下移",
          insertLineBelow: "在下方插入行",
          mergeWithNext: "与下一行合并",
          delete: "删除",
          play: "播放",
          pause: "暂停",
          mute: "静音",
          unmute: "取消静音",
          volume: "音量",
          toggleFullscreen: "切换全屏",
          loadingRefining: "正在微调时间...",
          loadingTranscribingStep1: "第 1/3 步：正在转录音频...",
          loadingTranscribingStep2: "第 2/3 步：正在分析音频并同步文本...",
          loadingTranscribingStep3: "第 3/3 步：正在微调时间精度...",
          loadingGeneratingStep1: "第 1/2 步：正在分析音频并同步文本...",
          loadingGeneratingStep2: "第 2/2 步：正在微调时间精度...",
          loadingGeneric: "处理长视频可能需要几分钟。",
          placeholder: "您生成的 SRT 文件将显示在此处。",
          mediaMissing: "缺少视频/音频文件",
          mediaMissingDescription: "请重新上传原始视频/音频文件以编辑和预览字幕。",
          errorGeneric: "发生意外错误。",
          errorFailedToProcess: "处理失败：{error}",
          errorApiKeyMissing: "应用程序配置不正确。缺少 API_KEY。请联系管理员。",
          errorFileTooLarge: "文件太大。请选择小于 {size}MB 的文件。",
          errorNoSubtitlesToRefine: "没有要微调的字幕。",
          errorNoSubtitlesToTranslate: "没有要翻译的字幕。",
          errorMediaNeededForRefine: "请上传视频/音频文件以使用微调功能。",
          errorMediaNeededForGenerate: "生成字幕前请上传视频/音频文件。",
          errorMediaNeededForTranscribe: "转录前请上传视频/音频文件。",
          errorLyricsNeededForGenerate: "文本为空。请输入文本以生成字幕。",
          errorFailedToParseFile: "解析文件失败：{error}",
          errorFileEmpty: "文件为空或无法读取。",
          errorUnsupportedFileType: "不支持的文件类型：.{extension}",
          errorNoEntriesFound: "在文件中未找到有效的字幕条目。",
          errorPasteBlocked: "浏览器阻止了按钮粘贴操作。\n\n这是现代网络浏览器中的常见安全措施。\n\n请使用键盘（Ctrl+V 或 Cmd+V）直接粘贴到文本区域。",
          draftRestored: "草稿已恢复。请重新上传原始视频/音频文件以使用预览和微调功能。",
          detectedFormatLoad: "检测到 {format} 格式。点击加载到编辑器。",
          poweredBy: "由 Google Gemini 驱动",
        },
      };

      const getInitialLang = () => {
        const browserLang = navigator.language;
        const foundLang = supportedLanguages.find(l => browserLang.startsWith(l.code));
        return foundLang ? foundLang.code : 'en';
      };

      // ** utils/fileUtils.ts **
      const fileToBase64 = (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => {
            const result = reader.result;
            const base64String = result.split(',')[1];
            if (base64String) {
              resolve(base64String);
            } else {
              reject(new Error("Failed to read file as base64. The result was empty."));
            }
          };
          reader.onerror = (error) => reject(error);
        });
      };

      // ** utils/srtUtils.ts **
      const normalizeTimestamp = (timestamp) => {
          if (!timestamp || typeof timestamp !== 'string') {
              return '00:00:00,000';
          }
          const trimmedTimestamp = timestamp.trim();
          const msMatch = trimmedTimestamp.match(/(.*)([.,:])(\d{1,3})$/);
          let timePart;
          let msPart = '000';
          if (msMatch) {
              timePart = msMatch[1];
              msPart = msMatch[3];
          } else {
              timePart = trimmedTimestamp;
          }
          const timeSegments = timePart.split(':').map(s => s.trim()).filter(Boolean);
          let hours = 0, minutes = 0, seconds = 0;
          if (timeSegments.length === 3) {
              hours = parseInt(timeSegments[0], 10) || 0;
              minutes = parseInt(timeSegments[1], 10) || 0;
              seconds = parseInt(timeSegments[2], 10) || 0;
          } else if (timeSegments.length === 2) {
              minutes = parseInt(timeSegments[0], 10) || 0;
              seconds = parseInt(timeSegments[1], 10) || 0;
          } else if (timeSegments.length === 1 && timeSegments[0] !== '') {
              seconds = parseInt(timeSegments[0], 10) || 0;
          }
          if (seconds >= 60) {
              minutes += Math.floor(seconds / 60);
              seconds %= 60;
          }
          if (minutes >= 60) {
              hours += Math.floor(minutes / 60);
              minutes %= 60;
          }
          const paddedHours = String(hours).padStart(2, '0');
          const paddedMinutes = String(minutes).padStart(2, '0');
          const paddedSeconds = String(seconds).padStart(2, '0');
          const paddedMs = msPart.padEnd(3, '0').substring(0, 3);
          return `${paddedHours}:${paddedMinutes}:${paddedSeconds},${paddedMs}`;
      };
      const timestampToMs = (timestamp) => {
          const normalized = normalizeTimestamp(timestamp);
          const match = normalized.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
          if (!match) return 0;
          const [, hours, minutes, seconds, ms] = match;
          return (parseInt(hours, 10) * 3600 + parseInt(minutes, 10) * 60 + parseInt(seconds, 10)) * 1000 + parseInt(ms, 10);
      };
      const msToTimestamp = (totalMs) => {
          if (totalMs < 0) totalMs = 0;
          const ms = Math.floor(totalMs % 1000);
          const totalSeconds = Math.floor(totalMs / 1000);
          const seconds = totalSeconds % 60;
          const totalMinutes = Math.floor(totalSeconds / 60);
          const minutes = totalMinutes % 60;
          const hours = Math.floor(totalMinutes / 60);
          const paddedHours = String(hours).padStart(2, '0');
          const paddedMinutes = String(minutes).padStart(2, '0');
          const paddedSeconds = String(seconds).padStart(2, '0');
          const paddedMs = String(ms).padStart(3, '0');
          return `${paddedHours}:${paddedMinutes}:${paddedSeconds},${paddedMs}`;
      };
      const parseSrt = (srtContent) => {
        if (!srtContent) return [];
        const entries = [];
        const blocks = srtContent.trim().split(/\r?\n\s*\r?\n/);
        for (const block of blocks) {
          const lines = block.trim().split(/\r?\n/);
          if (lines.length < 2) continue;
          const index = parseInt(lines[0], 10);
          const timeMatch = lines[1].match(/(.*?)\s*-->\s*(.*)/);
          if (isNaN(index) || !timeMatch) continue;
          const startTime = normalizeTimestamp(timeMatch[1]);
          const endTime = normalizeTimestamp(timeMatch[2]);
          const text = lines.slice(2).join('\n');
          entries.push({ index, startTime, endTime, text });
        }
        return entries;
      };
      const parseVtt = (vttContent) => {
          if (!vttContent) return [];
          const entries = [];
          const blocks = vttContent.trim().replace(/^WEBVTT\s*/, '').split(/\r?\n\s*\r?\n/);
          let entryIndex = 1;
          for (const block of blocks) {
              const lines = block.trim().split(/\r?\n/);
              if (lines.length === 0) continue;
              const timeMatch = lines[0].match(/(.*?)\s*-->\s*(.*?)(?:\s+.*)?$/);
              if (timeMatch) {
                  const startTime = normalizeTimestamp(timeMatch[1]);
                  const endTime = normalizeTimestamp(timeMatch[2]);
                  const text = lines.slice(1).join('\n');
                  entries.push({ index: entryIndex++, startTime, endTime, text });
              }
          }
          return entries;
      };
      const lrcTimestampToMs = (lrcTimestamp) => {
          const match = lrcTimestamp.match(/(\d{2}):(\d{2})\.(\d{2})/);
          if (!match) return 0;
          const [, minutes, seconds, centiseconds] = match;
          return (parseInt(minutes, 10) * 60 + parseInt(seconds, 10)) * 1000 + parseInt(centiseconds, 10) * 10;
      };
      const parseLrc = (lrcContent) => {
          if (!lrcContent) return [];
          const timedLines = [];
          const lines = lrcContent.trim().split(/\r?\n/);
          const lineRegex = /\[(\d{2}:\d{2}\.\d{2})\](.*)/;
          for (const line of lines) {
              const match = line.match(lineRegex);
              if (match) {
                  const timeMs = lrcTimestampToMs(match[1]);
                  const text = match[2].trim();
                  if (text) {
                      timedLines.push({ timeMs, text });
                  }
              }
          }
          if (timedLines.length === 0) return [];
          return timedLines.map((line, i) => {
              const startTimeMs = line.timeMs;
              const endTimeMs = (i < timedLines.length - 1) 
                  ? timedLines[i + 1].timeMs 
                  : startTimeMs + 3000;
              return {
                  index: i + 1,
                  startTime: msToTimestamp(startTimeMs),
                  endTime: msToTimestamp(endTimeMs),
                  text: line.text,
              };
          });
      };
      const serializeSrt = (entries) => {
        return entries
          .map((entry, i) => {
            const index = i + 1;
            const normalizedStartTime = normalizeTimestamp(entry.startTime);
            const normalizedEndTime = normalizeTimestamp(entry.endTime);
            const srtStartTime = normalizedStartTime;
            const srtEndTime = normalizedEndTime;
            const textWithCrlf = entry.text.replace(/\r?\n/g, '\r\n');
            return `${index}\r\n${srtStartTime} --> ${srtEndTime}\r\n${textWithCrlf}`;
          })
          .join('\r\n\r\n');
      };
      const srtToVtt = (srtContent) => {
        if (!srtContent) return 'WEBVTT';
        const vttHeader = 'WEBVTT\n\n';
        const blocks = srtContent.trim().split(/\r?\n\s*\r?\n/);
        const vttBlocks = blocks.map(block => {
          const lines = block.split(/\r?\n/);
          if (lines.length < 2) {
            return '';
          }
          const timestampIndex = lines.findIndex(line => line.includes('-->'));
          if (timestampIndex === -1) {
            return '';
          }
          let timestampLine = lines[timestampIndex];
          timestampLine = timestampLine.replace(/,(\d{3})/g, '.$1');
          timestampLine += ' line:45% position:50% align:middle size:80%';
          const textLines = lines.slice(timestampIndex + 1);
          return `${timestampLine}\n${textLines.join('\n')}`;
        }).filter(block => block).join('\n\n');
        return vttHeader + vttBlocks;
      };
      const msToLrcTimestamp = (totalMs) => {
          if (totalMs < 0) totalMs = 0;
          const totalSeconds = Math.floor(totalMs / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          const centiseconds = Math.floor((totalMs % 1000) / 10);
          const paddedMinutes = String(minutes).padStart(2, '0');
          const paddedSeconds = String(seconds).padStart(2, '0');
          const paddedCentiseconds = String(centiseconds).padStart(2, '0');
          return `[${paddedMinutes}:${paddedSeconds}.${paddedCentiseconds}]`;
      };
      const serializeLrc = (entries) => {
          return entries
            .map(entry => {
              const timestampMs = timestampToMs(entry.startTime);
              const lrcTimestamp = msToLrcTimestamp(timestampMs);
              const text = entry.text.replace(/\r?\n/g, ' ');
              return `${lrcTimestamp}${text}`;
            })
            .join('\r\n');
      };

      // ** services/geminiService.ts **
      const API_KEY = process.env.API_KEY;
      const API_KEY_MISSING_ERROR = 'API_KEY_MISSING';
      const ensureApiKey = () => {
          if (!API_KEY) {
              throw new Error(API_KEY_MISSING_ERROR);
          }
      };
      if (!API_KEY) {
        console.error("API_KEY environment variable is not set.");
      }
      const ai = new GoogleGenAI({ apiKey: API_KEY });
      const extractJson = (text) => {
          const match = text.match(/```json\s*([\s\S]*?)\s*```/);
          if (match && match[1]) {
              return match[1];
          }
          const firstBracket = text.indexOf('[');
          const lastBracket = text.lastIndexOf(']');
          if (firstBracket !== -1 && lastBracket !== -1) {
              return text.substring(firstBracket, lastBracket + 1);
          }
          const firstBrace = text.indexOf('{');
          const lastBrace = text.lastIndexOf('}');
           if (firstBrace !== -1 && lastBrace !== -1) {
              return text.substring(firstBrace, lastBrace + 1);
          }
          return text.trim();
      };
      const srtDataSchema = {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              index: { type: Type.INTEGER },
              startTime: { type: Type.STRING },
              endTime: { type: Type.STRING },
              text: { type: Type.STRING },
            },
            required: ["index", "startTime", "endTime", "text"],
          },
      };
      const languageDetectionSchema = {
          type: Type.OBJECT,
          properties: {
              languageCode: {
                  type: Type.STRING,
                  description: "The two-letter ISO 639-1 code for the detected language (e.g., 'en', 'ja')."
              }
          },
          required: ["languageCode"]
      };
      const processAiResponse = (rawText) => {
          if (!rawText) {
              throw new Error("The AI returned an empty response.");
          }
          const cleanedJsonString = extractJson(rawText);
          let result;
          try {
              result = JSON.parse(cleanedJsonString);
          } catch (parseError) {
              console.error("Failed to parse cleaned JSON:", cleanedJsonString);
              throw new Error("The AI returned data in a format that could not be read.");
          }
          if (Array.isArray(result) && result.every(item => 
              typeof item.index === 'number' &&
              typeof item.startTime === 'string' &&
              typeof item.endTime === 'string' &&
              typeof item.text === 'string'
          )) {
             if (result.length === 0) {
              throw new Error("The AI returned an empty list of subtitles.");
            }
            const normalizedResult = result.map(item => ({
                  ...item,
                  startTime: normalizeTimestamp(item.startTime),
                  endTime: normalizeTimestamp(item.endTime),
            }));
            return normalizedResult;
          } else {
            console.error("AI response did not match expected schema:", result);
            throw new Error("The AI response was not in the expected format.");
          }
      }
      const generateSrtFromVideoAndText = async (videoBase64, mimeType, textToSync) => {
        ensureApiKey();
        try {
          const videoPart = { inlineData: { data: videoBase64, mimeType: mimeType } };
          const prompt = `
      You are a subtitle generation expert. Your task is to synchronize the provided text with the audio from the video.
      Return a JSON array where each object represents a subtitle line.

      **JSON Object Structure:**
      - \`index\`: Sequential number, starting at 1.
      - \`startTime\`: Start timestamp in \`HH:MM:SS,ms\` format (e.g., \`00:01:23,456\`). **Crucially, use a comma (,) before the milliseconds.**
      - \`endTime\`: End timestamp in \`HH:MM:SS,ms\` format (e.g., \`00:01:25,789\`). **Crucially, use a comma (,) before the milliseconds.**
      - \`text\`: The line of text.

      **Important Rules:**
      1.  Analyze the video's audio to find the precise start and end times for each line of the provided text.
      2.  Make a best-effort guess for timings if a perfect match is not possible. Do not leave any text line out.
      3.  The final output must be ONLY the JSON array. Do not include any other text or markdown.

      **Text to synchronize:**
      ---
      ${textToSync}
      ---
      `;
          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [videoPart, { text: prompt }] },
            config: {
              responseMimeType: "application/json",
              responseSchema: srtDataSchema,
            },
          });
          return processAiResponse(response.text);
        } catch (error) {
          console.error("Error generating SRT content:", error);
          if (error instanceof Error) {
              throw new Error(`Failed to generate subtitles. Details: ${error.message}`);
          }
          throw new Error("An unknown error occurred while generating subtitles.");
        }
      };
      const refineSrtTimings = async (videoBase64, mimeType, currentEntries) => {
          ensureApiKey();
          try {
              const videoPart = { inlineData: { data: videoBase64, mimeType: mimeType } };
              const prompt = `
      You are an expert subtitle timing refinement tool.
      Your task is to analyze the audio from the provided video and adjust the timings for an existing set of subtitles to be as precise as possible.

      **Input:** You will receive a JSON array of subtitle entries.
      **Output:** You must return the full, updated list of subtitles in the exact same JSON array format.

      **IMPORTANT Rules:**
      1.  Adjust the \`startTime\` and \`endTime\` for each entry to perfectly match when the vocals for that line are sung.
      2.  **Crucially for \`endTime\`, the timestamp must mark the *very end* of the vocal phrase. This includes sustained notes (long tones), reverberation, and vocal trails. The subtitle should remain visible until the singer's voice for that specific text has completely faded or the next sung line begins.**
      3.  DO NOT change the \`text\`, \`index\`, or the order of the entries.
      4.  Ensure timestamps are in \`HH:MM:SS,ms\` format. **Use a comma (,) before the milliseconds.**
      5.  Your entire response must be ONLY the JSON array. Do not add any extra text, explanations, or markdown formatting.

      **Subtitles to refine:**
      ---
      ${JSON.stringify(currentEntries, null, 2)}
      ---
      `;
              const response = await ai.models.generateContent({
                  model: 'gemini-2.5-flash',
                  contents: { parts: [videoPart, { text: prompt }] },
                  config: {
                    responseMimeType: "application/json",
                    responseSchema: srtDataSchema,
                  },
              });
              const refinedEntries = processAiResponse(response.text);
              if (refinedEntries.length !== currentEntries.length) {
                  console.error("Refinement process failed: AI returned a different number of entries.", { originalCount: currentEntries.length, refinedCount: refinedEntries.length });
                  throw new Error("The AI failed to follow instructions and changed the number of subtitle lines. Please try again.");
              }
              const resilientRefinedEntries = currentEntries.map((originalEntry, i) => {
                  const refinedEntry = refinedEntries[i];
                  return { ...originalEntry, startTime: refinedEntry.startTime, endTime: refinedEntry.endTime };
              });
              return resilientRefinedEntries;
          } catch (error) {
              console.error("Error refining SRT timings:", error);
              if (error instanceof Error) {
                  throw new Error(`Failed to refine timings. Details: ${error.message}`);
              }
              throw new Error("An unknown error occurred while refining timings.");
          }
      };
      const transcribeAudio = async (videoBase64, mimeType) => {
        ensureApiKey();
        try {
          const audioPart = { inlineData: { data: videoBase64, mimeType: mimeType } };
          const prompt = `
      You are an expert audio transcription service.
      Your task is to transcribe the audio from the provided video/audio file accurately.
      Please format the output with appropriate line breaks to ensure readability.
      - If the content sounds like song lyrics, format each sung line on a new line.
      - If the content is spoken word (like a speech or dialogue), break the text into paragraphs or sentences at natural pauses.
      Your final output should be only the transcribed text. Do not add any titles, headers, or other formatting.
      `;
          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [audioPart, { text: prompt }] },
          });
          return response.text.trim();
        } catch (error) {
          console.error("Error transcribing audio:", error);
          if (error instanceof Error) {
              throw new Error(`Failed to transcribe audio. Details: ${error.message}`);
          }
          throw new Error("An unknown error occurred while transcribing audio.");
        }
      };
      const translateSrtText = async (currentEntries, targetLanguage) => {
        ensureApiKey();
        try {
          const prompt = `
      You are an expert multilingual translator.
      Your task is to translate ONLY the 'text' field for each entry in the provided JSON array into ${targetLanguage}.

      **IMPORTANT Rules:**
      1.  Translate the 'text' field accurately, preserving the original meaning and tone.
      2.  DO NOT change the 'index', 'startTime', 'or 'endTime' fields.
      3.  Preserve the original structure of the JSON array and all its objects.
      4.  Your entire response must be ONLY the translated JSON array. Do not add any extra text, explanations, or markdown formatting.

      **JSON to translate:**
      ---
      ${JSON.stringify(currentEntries, null, 2)}
      ---
      `;
          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [{ text: prompt }] },
            config: {
              responseMimeType: "application/json",
              responseSchema: srtDataSchema,
            },
          });
          const translatedEntries = processAiResponse(response.text);
          if (translatedEntries.length !== currentEntries.length) {
            console.error("Translation process failed: AI returned a different number of entries.", { originalCount: currentEntries.length, translatedCount: translatedEntries.length });
            throw new Error("The AI failed to follow instructions and changed the number of subtitle lines. Please try again.");
          }
          const resilientTranslatedEntries = currentEntries.map((originalEntry, i) => {
            const translatedEntry = translatedEntries[i];
            return { ...originalEntry, text: translatedEntry.text };
          });
          return resilientTranslatedEntries;
        } catch (error) {
          console.error("Error translating SRT text:", error);
          if (error instanceof Error) {
            throw new Error(`Failed to translate subtitles. Details: ${error.message}`);
          }
          throw new Error("An unknown error occurred while translating subtitles.");
        }
      };
       const detectLanguage = async (textToDetect) => {
        if (!textToDetect || textToDetect.trim().length < 10) {
            return null;
        }
        ensureApiKey();
        try {
            const prompt = `
                Analyze the following text and determine its primary language.
                Return ONLY the two-letter ISO 639-1 code for the language.
                For example, for English text, return "en". For Japanese, return "ja".
                If multiple languages are present, identify the most dominant one.

                Text to analyze:
                ---
                ${textToDetect.substring(0, 2000)}
                ---
            `;
            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: { parts: [{ text: prompt }] },
                config: {
                    responseMimeType: "application/json",
                    responseSchema: languageDetectionSchema,
                },
            });
            const jsonString = extractJson(response.text);
            const result = JSON.parse(jsonString);
            if (result && typeof result.languageCode === 'string' && result.languageCode.length > 1) {
                return result.languageCode.toLowerCase().split('-')[0];
            }
            return null;
        } catch (error) {
            console.error("Error detecting language:", error);
            return null;
        }
      };

      // ** components/icons.tsx **
      const CE = React.createElement;
      const UploadIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" }));
      const VideoIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" }));
      const DownloadIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }));
      const CopyIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" }));
      const CheckIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M5 13l4 4L19 7" }));
      const TrashIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" }));
      const ArrowUpIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M5 15l7-7 7 7" }));
      const ArrowDownIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 9l-7 7-7-7" }));
      const PlusIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 4v16m8-8H4" }));
      const EditIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" }));
      const PlayIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" }), CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }));
      const ChevronDoubleDownIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 13l-7 7-7-7m14-8l-7 7-7-7" }));
      const UndoIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "2" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M11 15l-3-3m0 0l3-3m-3 3h8a5 5 0 000-10H9" }));
      const RedoIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "2" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M13 15l3-3m0 0l-3-3m3 3H5a5 5 0 000 10h1" }));
      const ArchiveBoxIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "2" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" }), CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 12l8 4 8-4" }));
      const SparklesIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.562L16.25 22.5l-.648-1.938a2.25 2.25 0 01-1.465-1.465L12 18.75l1.938-.648a2.25 2.25 0 011.465-1.465L17.25 15l.648 1.938a2.25 2.25 0 011.465 1.465L21 18.75l-1.938.648a2.25 2.25 0 01-1.465 1.465z" }));
      const ArrowPathIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.18-3.185m-3.181 9.995l-3.182-3.182a8.25 8.25 0 010-11.664l3.181-3.182m0 0h-4.992m4.992 0v4.992" }));
      const GripVerticalIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, CE('circle', { cx: "9", cy: "12", r: "1" }), CE('circle', { cx: "9", cy: "5", r: "1" }), CE('circle', { cx: "9", cy: "19", r: "1" }), CE('circle', { cx: "15", cy: "12", r: "1" }), CE('circle', { cx: "15", cy: "5", r: "1" }), CE('circle', { cx: "15", cy: "19", r: "1" }));
      const XIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" }));
      const MusicNoteIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163z" }), CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 9V4.5M9 9l-3 1.5M12 12v5.25m0 0l-3 1.5m3-1.5l3-1.5m-3 1.5V12m6-6v4.5m0-4.5l-3 1.5m3-1.5l-3-1.5M9 15v5.25m0 0l-3 1.5m3-1.5l3-1.5m-3 1.5V15" }));
      const TargetIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M15.042 21.672L13.684 16.6m0 0l-2.51 2.225.569-2.474-1.905-1.338 2.324-.318L13.684 10l.693 2.563 2.324.317-1.905 1.338.569 2.474zM12 6.375a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zM12 21.75a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0z" }));
      const ScissorsIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M8.25 3.75H19.5M8.25 3.75V19.5M8.25 3.75C5.48 3.75 3 5.954 3 8.625c0 2.67 2.48 4.875 5.25 4.875V19.5M8.25 19.5C5.48 19.5 3 17.296 3 14.625c0-2.67 2.48-4.875 5.25-4.875" }));
      const PauseIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" }));
      const VolumeUpIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" }));
      const VolumeOffIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z", clipRule: "evenodd" }), CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" }));
      const ExpandIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5-5" }));
      const ChevronDownIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M19.5 8.25l-7.5 7.5-7.5-7.5" }));
      const MicrophoneIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5 }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 016 0v8.25a3 3 0 01-3 3z" }));
      const ClipboardPasteIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a2.25 2.25 0 01-2.25 2.25h-1.5a2.25 2.25 0 01-2.25-2.25v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184" }));
      const LanguageIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M10.5 21l5.25-11.25L21 21m-9-3h7.5M3 5.621a48.474 48.474 0 016-.371m0 0c1.12 0 2.233.038 3.334.114M9 5.25V3m3.334 2.364C13.18 7.061 14.1 10.038 14.1 12c0 1.962-.92 4.939-1.766 7.636M12 21v-2.25m-3.334-2.364C7.82 13.939 6.9 10.962 6.9 9c0-1.962.92-4.939 1.766-7.636" }));
      const InformationCircleIcon = ({ className }) => CE('svg', { className, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor" }, CE('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" }));
      
      // ** components/Loader.tsx **
      const Loader = ({ message, t }) => {
        return CE('div', { className: "flex flex-col items-center justify-center h-full text-center p-8 bg-gray-800/50 rounded-lg" },
          CE('div', { className: "w-16 h-16 border-4 border-dashed rounded-full animate-spin border-teal-400" }),
          CE('p', { className: "mt-4 text-lg text-gray-300" }, message),
          CE('p', { className: "mt-2 text-sm text-gray-400" }, t('loadingGeneric'))
        );
      };

      // ** components/FileUpload.tsx **
      const FileUpload = ({ videoFile, setVideoFile, disabled, videoUrl, t }) => {
        const [isPlaying, setIsPlaying] = useState(false);
        const audioRef = useRef(null);
        const handleFileChange = (e) => {
          if (e.target.files && e.target.files[0]) {
            setVideoFile(e.target.files[0]);
          }
        };
        const handleDragOver = (e) => e.preventDefault();
        const handleDrop = (e) => {
          e.preventDefault();
          if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            setVideoFile(e.dataTransfer.files[0]);
          }
        };
        const handlePlayPause = () => {
          const audio = audioRef.current;
          if (audio) {
            if (audio.paused) audio.play();
            else audio.pause();
          }
        };
        const isAudio = videoFile?.type.startsWith('audio/');
        if (videoFile && videoUrl) {
          if (isAudio) {
            return CE('div', { className: "relative group" },
              CE('audio', { ref: audioRef, src: videoUrl, onPlay: () => setIsPlaying(true), onPause: () => setIsPlaying(false), onEnded: () => setIsPlaying(false), className: "hidden" }),
              CE('div', { onClick: handlePlayPause, className: "bg-gray-800 rounded-lg p-3 flex items-center w-full cursor-pointer hover:bg-gray-700 transition-colors", role: "button", "aria-label": `Play or pause audio file ${videoFile.name}` },
                CE('button', { className: "p-2 rounded-full bg-gray-700/50 hover:bg-gray-600 text-white flex-shrink-0 mr-3", "aria-label": isPlaying ? t('pause') : t('play') },
                  isPlaying ? CE(PauseIcon, { className: "w-5 h-5" }) : CE(PlayIcon, { className: "w-5 h-5" })
                ),
                CE('span', { className: "text-sm text-gray-300 truncate", title: videoFile.name }, videoFile.name)
              ),
              CE('div', { className: "absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 z-20" },
                CE('button', { onClick: (e) => { e.stopPropagation(); setVideoFile(null); }, disabled, className: "px-3 py-1 text-sm bg-red-600 bg-opacity-80 hover:bg-red-700 hover:bg-opacity-100 text-white rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition-all", "aria-label": t('removeMedia'), title: t('removeMedia') }, t('removeMedia'))
              )
            );
          }
          return CE('div', { className: "relative group bg-black rounded-lg max-h-48 flex items-center justify-center" },
            CE('video', { src: videoUrl, controls: true, className: "w-full max-h-full max-w-full rounded-lg object-contain relative z-10 bg-transparent", "aria-label": "Video preview" }, "Your browser does not support the video tag."),
            CE('div', { className: "absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 z-20" },
              CE('button', { onClick: () => setVideoFile(null), disabled, className: "px-3 py-1 text-sm bg-red-600 bg-opacity-80 hover:bg-red-700 hover:bg-opacity-100 text-white rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition-all", "aria-label": t('removeMedia'), title: t('removeMedia') }, t('removeMedia'))
            )
          );
        }
        return CE('div', { className: "flex items-center justify-center w-full" },
          CE('label', { htmlFor: "dropzone-file", onDragOver: handleDragOver, onDrop: handleDrop, className: `flex flex-col items-center justify-center w-full h-40 border-2 border-gray-600 border-dashed rounded-lg cursor-pointer bg-gray-800 hover:bg-gray-700 transition-colors ${disabled ? 'opacity-50 cursor-not-allowed' : ''}` },
            CE('div', { className: "flex flex-col items-center justify-center pt-5 pb-6" },
              CE(UploadIcon, { className: "w-10 h-10 mb-3 text-gray-400" }),
              CE('p', { className: "mb-2 text-sm text-gray-400" }, CE('span', { className: "font-semibold text-teal-400" }, t('clickToUpload')), t('dragAndDrop')),
              CE('p', { className: "text-xs text-gray-400" }, t('fileTypes')),
              CE('p', { className: "text-xs text-gray-400" }, t('maxFileSize', {size: 15}))
            ),
            CE('input', { id: "dropzone-file", type: "file", className: "hidden", accept: "video/*,audio/*", onChange: handleFileChange, disabled })
          )
        );
      };

      // ** components/TextInput.tsx **
      const TextInput = ({ textInput, setTextInput, disabled, t }) => {
        const [copied, setCopied] = useState(false);
        const textareaRef = useRef(null);
        const handleCopy = () => {
          if (textInput) {
              navigator.clipboard.writeText(textInput).then(() => {
                  setCopied(true);
                  setTimeout(() => setCopied(false), 2000);
              }).catch(err => {
                  console.error('Failed to copy text: ', err);
                  alert('Failed to copy text. Please try again.');
              });
          }
        };
        return CE('div', { className: "flex flex-col h-full" },
          CE('div', { className: "relative flex-grow" },
            CE('textarea', { ref: textareaRef, id: "lyrics", "aria-label": "Paste Text", value: textInput, onChange: (e) => setTextInput(e.target.value), disabled, placeholder: t('lyricsPlaceholder'), className: "w-full h-full p-4 pr-16 bg-gray-800 border border-gray-600 rounded-lg resize-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" }),
            CE('div', { className: "absolute top-2.5 right-2.5 flex items-center gap-1" },
              textInput.length > 0 && !disabled && CE(React.Fragment, null,
                CE('button', { onClick: handleCopy, className: "p-1 rounded-full text-gray-400 hover:bg-gray-600 hover:text-white transition-colors", "aria-label": copied ? t('copied') : t('copyLyrics'), title: copied ? t('copied') : t('copyLyrics') },
                  copied ? CE(CheckIcon, { className: "w-5 h-5 text-teal-400" }) : CE(CopyIcon, { className: "w-5 h-5" })
                ),
                CE('button', { onClick: () => setTextInput(''), className: "p-1 rounded-full text-gray-400 hover:bg-gray-600 hover:text-white transition-colors", "aria-label": t('clearLyrics'), title: t('clearLyrics') },
                  CE(XIcon, { className: "w-5 h-5" })
                )
              )
            )
          )
        );
      };

      // ** components/CustomVideoControls.tsx **
      const CustomVideoControls = ({ isPlaying, onPlayPause, currentTime, duration, onSeek, volume, onVolumeChange, isMuted, onMuteToggle, onFullscreen, isVisible, t }) => {
        const formatTime = (timeInSeconds) => {
          if (isNaN(timeInSeconds) || timeInSeconds < 0) return '00:00';
          const time = Math.floor(timeInSeconds);
          const minutes = Math.floor(time / 60);
          const seconds = time % 60;
          return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };
        const progress = duration > 0 ? (currentTime / duration) * 100 : 0;
        return CE('div', { className: `absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-black/80 to-transparent transition-opacity duration-300 ${isVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'}`, onClick: (e) => e.stopPropagation() },
          CE('div', { className: "relative mb-2 group" },
            CE('input', { type: "range", min: "0", max: duration || 0, value: currentTime, onChange: (e) => onSeek(parseFloat(e.target.value)), className: "w-full h-1.5 bg-gray-500/50 rounded-lg appearance-none cursor-pointer group-hover:h-2 transition-all duration-200", style: { background: `linear-gradient(to right, #2DD4BF ${progress}%, #4B5563 ${progress}%)` }, "aria-label": "Seek slider", title: `Seek: ${formatTime(currentTime)}` })
          ),
          CE('div', { className: "flex items-center justify-between" },
            CE('div', { className: "flex items-center gap-4" },
              CE('button', { onClick: onPlayPause, className: "text-white hover:text-teal-400 transition-colors", "aria-label": isPlaying ? t('pause') : t('play'), title: isPlaying ? `${t('pause')} (Space)` : `${t('play')} (Space)` },
                isPlaying ? CE(PauseIcon, { className: "w-8 h-8" }) : CE(PlayIcon, { className: "w-8 h-8" })
              ),
              CE('div', { className: "flex items-center gap-2" },
                CE('button', { onClick: onMuteToggle, className: "text-white hover:text-teal-400 transition-colors", "aria-label": isMuted ? t('unmute') : t('mute'), title: isMuted ? t('unmute') : t('mute') },
                  isMuted || volume === 0 ? CE(VolumeOffIcon, { className: "w-6 h-6" }) : CE(VolumeUpIcon, { className: "w-6 h-6" })
                ),
                CE('input', { type: "range", min: "0", max: "1", step: "0.05", value: isMuted ? 0 : volume, onChange: (e) => onVolumeChange(parseFloat(e.target.value)), className: "w-24 h-1.5 bg-gray-500/50 rounded-lg appearance-none cursor-pointer", "aria-label": t('volume'), title: `${t('volume')}: ${Math.round((isMuted ? 0 : volume) * 100)}%` })
              )
            ),
            CE('div', { className: "flex items-center gap-4" },
              CE('span', { className: "text-sm font-mono text-white" }, `${formatTime(currentTime)} / ${formatTime(duration)}`),
              CE('button', { onClick: onFullscreen, className: "text-white hover:text-teal-400 transition-colors", "aria-label": t('toggleFullscreen'), title: t('toggleFullscreen') },
                CE(ExpandIcon, { className: "w-6 h-6" })
              )
            )
          )
        );
      };

      // ** components/VideoPreview.tsx **
      const VideoPreview = forwardRef(({ videoFile, videoUrl, entries, onTimeUpdate, t }, ref) => {
        const localVideoRef = useRef(null);
        const containerRef = useRef(null);
        const trackRef = useRef(null);
        const controlsTimeoutRef = useRef(null);
        const [isPlaying, setIsPlaying] = useState(false);
        const [duration, setDuration] = useState(0);
        const [volume, setVolume] = useState(1);
        const [isMuted, setIsMuted] = useState(false);
        const [currentTime, setCurrentTime] = useState(0);
        const [areControlsVisible, setAreControlsVisible] = useState(true);
        const [isTrackReady, setIsTrackReady] = useState(false);

        useImperativeHandle(ref, () => localVideoRef.current);

        useEffect(() => {
          const video = localVideoRef.current;
          if (!video) return;
          setIsTrackReady(false);
          const setupTrack = () => {
            let track = Array.from(video.textTracks).find(t => t.label === 'Live Subtitles');
            if (!track) {
              track = video.addTextTrack('subtitles', 'Live Subtitles', 'en');
            }
            track.mode = 'showing';
            trackRef.current = track;
            setIsTrackReady(true);
          };
          if (video.readyState >= 1) {
            setupTrack();
          } else {
            video.addEventListener('loadedmetadata', setupTrack, { once: true });
          }
          setVolume(video.volume);
          setIsMuted(video.muted);
          return () => {
            video.removeEventListener('loadedmetadata', setupTrack);
            setIsTrackReady(false);
          };
        }, [videoUrl]);

        useEffect(() => {
          if (!isTrackReady) return;
          const track = trackRef.current;
          if (!track) return;
          if (track.cues) {
            while (track.cues.length > 0) {
              track.removeCue(track.cues[0]);
            }
          }
          entries.forEach(entry => {
            const startTime = timestampToMs(entry.startTime) / 1000;
            const endTime = timestampToMs(entry.endTime) / 1000;
            if (startTime < endTime) {
              const cue = new VTTCue(startTime, endTime, entry.text);
              cue.line = 90;
              cue.lineAlign = 'end';
              cue.position = 50;
              cue.align = 'center';
              cue.size = 80;
              track.addCue(cue);
            }
          });
        }, [entries, isTrackReady]);

        const handlePlayPause = () => {
          const video = localVideoRef.current;
          if (video) video.paused ? video.play() : video.pause();
        };
        const handleSeek = (time) => {
          const video = localVideoRef.current;
          if (video) {
            video.currentTime = time;
            setCurrentTime(time);
          }
        };
        const handleVolumeChange = (newVolume) => {
          const video = localVideoRef.current;
          if (video) {
            video.muted = false;
            video.volume = newVolume;
          }
        };
        const handleMuteToggle = () => {
          const video = localVideoRef.current;
          if (video) video.muted = !video.muted;
        };
        const handleFullscreen = () => {
          const container = containerRef.current;
          if (container) {
            if (!document.fullscreenElement) {
              container.requestFullscreen().catch(err => {
                alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
              });
            } else {
              document.exitFullscreen();
            }
          }
        };
        const handleTimeUpdateEvent = (e) => {
          const time = e.currentTarget.currentTime;
          setCurrentTime(time);
          onTimeUpdate(time);
        };
        const handleLoadedMetadata = (e) => setDuration(e.currentTarget.duration);
        const handleVolumeChangeOnVideo = (e) => {
          setVolume(e.currentTarget.volume);
          setIsMuted(e.currentTarget.muted);
        };
        const showControls = () => {
          if (controlsTimeoutRef.current) clearTimeout(controlsTimeoutRef.current);
          setAreControlsVisible(true);
          controlsTimeoutRef.current = window.setTimeout(() => {
            if (!localVideoRef.current?.paused) setAreControlsVisible(false);
          }, 3000);
        };
        const handleContainerClick = () => handlePlayPause();
        useEffect(() => {
          const container = containerRef.current;
          const video = localVideoRef.current;
          const handleMouseLeave = () => {
              if (video && !video.paused) setAreControlsVisible(false);
          };
          if (container) {
            container.addEventListener('mousemove', showControls);
            container.addEventListener('mouseleave', handleMouseLeave);
          }
          return () => {
            if (container) {
              container.removeEventListener('mousemove', showControls);
              container.removeEventListener('mouseleave', handleMouseLeave);
            }
            if (controlsTimeoutRef.current) clearTimeout(controlsTimeoutRef.current);
          }
        }, [isPlaying]);

        return CE('div', { ref: containerRef, className: "w-full h-full flex items-center justify-center relative bg-black group", onClick: handleContainerClick },
          CE('video', {
            ref: localVideoRef,
            crossOrigin: "anonymous",
            className: "w-full h-full max-h-full max-w-full object-contain",
            onTimeUpdate: handleTimeUpdateEvent,
            onLoadedMetadata: handleLoadedMetadata,
            onPlay: () => { setIsPlaying(true); showControls(); },
            onPause: () => { setIsPlaying(false); setAreControlsVisible(true); },
            onVolumeChange: handleVolumeChangeOnVideo,
            key: videoUrl,
          }, CE('source', { src: videoUrl, type: videoFile.type }), "Your browser does not support the video tag."),
          CE(CustomVideoControls, {
            isPlaying,
            onPlayPause: handlePlayPause,
            currentTime,
            duration,
            onSeek: handleSeek,
            volume,
            onVolumeChange: handleVolumeChange,
            isMuted,
            onMuteToggle: handleMuteToggle,
            onFullscreen: handleFullscreen,
            isVisible: areControlsVisible,
            t: t,
          })
        );
      });

      // ** components/SrtEntry.tsx **
      const SrtEntry = ({ entry, onUpdate, onSetTimeToCurrent, onContextMenu, onSplit, onClick, isActive, isCurrent, isFirst, isLast, index, isDragging, isDragOver, onDragStart, onDragOver, onDrop, onDragEnd, t }) => {
        const [startTime, setStartTime] = useState(entry.startTime);
        const [endTime, setEndTime] = useState(entry.endTime);
        const [cursorPosition, setCursorPosition] = useState(0);
        const textAreaRef = useRef(null);

        useEffect(() => {
          setStartTime(entry.startTime);
          setEndTime(entry.endTime);
        }, [entry.startTime, entry.endTime]);

        const handleTimeChange = (e, field) => {
          if (field === 'startTime') setStartTime(e.target.value);
          else setEndTime(e.target.value);
        };
        const handleTimeBlur = (field) => {
          const value = field === 'startTime' ? startTime : endTime;
          const normalizedValue = normalizeTimestamp(value);
          if (field === 'startTime') setStartTime(normalizedValue);
          else setEndTime(normalizedValue);
          const parentValue = field === 'startTime' ? entry.startTime : entry.endTime;
          if (normalizedValue !== parentValue) {
            onUpdate(entry.index, field, normalizedValue);
          }
        };
        const handleTextChange = (e) => onUpdate(entry.index, 'text', e.target.value);
        const handleTextareaEvent = () => {
          if (textAreaRef.current) setCursorPosition(textAreaRef.current.selectionStart);
        };
        const handleSplitClick = () => {
          if (cursorPosition > 0 && cursorPosition < entry.text.length) onSplit(entry.index, cursorPosition);
        };
        const handleTimeKeyDown = (e, field) => {
          if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
          e.preventDefault();
          const currentValue = entry[field];
          const ms = timestampToMs(currentValue);
          const increment = e.shiftKey ? 1000 : 100;
          const newMs = e.key === 'ArrowUp' ? ms + increment : ms - increment;
          const newTimestamp = msToTimestamp(newMs);
          onUpdate(entry.index, field, newTimestamp);
        };

        const containerClasses = [
          "bg-gray-900/70", "rounded-lg", "p-3", "flex", "gap-3", "items-start", "transition-all", "duration-200", "cursor-pointer", "border",
          isDragging ? "opacity-30" : "opacity-100",
          isDragOver ? "border-teal-500 ring-2 ring-teal-500" :
          isActive ? "border-blue-500 ring-2 ring-blue-500" :
          isCurrent ? "border-teal-700 bg-teal-900/30" :
          "border-transparent hover:bg-gray-800/90",
        ].filter(Boolean).join(" ");
        
        const TimeInput = ({ field, value }) => CE('div', { className: "relative group" },
          CE('input', { type: "text", value, onChange: (e) => handleTimeChange(e, field), onBlur: () => handleTimeBlur(field), onKeyDown: (e) => handleTimeKeyDown(e, field), className: "w-full bg-gray-700 font-mono text-sm p-1 rounded border border-gray-600 focus:ring-1 focus:ring-teal-500 focus:border-teal-500 outline-none pr-7", "aria-label": `${field === 'startTime' ? 'Start' : 'End'} time for entry ${entry.index}. Use Arrow keys to adjust.`, title: "Use Arrow Up/Down to adjust by 100ms. Hold Shift for 1s." }),
          CE('button', { onClick: () => onSetTimeToCurrent(entry.index, field), className: "absolute right-0 top-0 h-full px-1.5 flex items-center text-gray-400 hover:text-teal-400 opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity", title: t('setTimeToCurrent'), "aria-label": `Set ${field === 'startTime' ? 'start' : 'end'} time to video's current time` },
            CE(TargetIcon, { className: "w-4 h-4" })
          )
        );

        return CE('div', { className: containerClasses, onClick, onContextMenu, draggable: true, onDragStart: (e) => onDragStart(e, index), onDragOver: (e) => onDragOver(e, index), onDrop: (e) => onDrop(e, index), onDragEnd },
          CE('div', { className: "flex-shrink-0 cursor-move pt-1", title: t('dragToReorder') },
            CE(GripVerticalIcon, { className: "w-5 h-5 text-gray-400" })
          ),
          CE('div', { className: "flex-grow" },
            CE('div', { className: "flex items-center gap-2 mb-2 w-full max-w-sm" },
              CE('span', { className: "font-mono text-xs text-gray-400 select-none w-6 text-center" }, entry.index),
              CE('div', { className: "flex-1" }, CE(TimeInput, { field: "startTime", value: startTime })),
              CE('span', { className: "text-gray-400" }, "→"),
              CE('div', { className: "flex-1" }, CE(TimeInput, { field: "endTime", value: endTime }))
            ),
            CE('textarea', { ref: textAreaRef, value: entry.text, onChange: handleTextChange, onKeyUp: handleTextareaEvent, onMouseUp: handleTextareaEvent, onFocus: handleTextareaEvent, className: "w-full bg-gray-800 p-2 rounded border border-gray-600 resize-y min-h-[4rem] focus:ring-1 focus:ring-teal-500 focus:border-teal-500 outline-none", rows: 2, "aria-label": `Text for entry ${entry.index}` }),
            isActive && CE('div', { className: "mt-2" },
              CE('button', { onClick: handleSplitClick, disabled: cursorPosition === 0 || cursorPosition >= entry.text.length, className: "flex items-center gap-1.5 px-2 py-1 text-xs bg-gray-600 hover:bg-indigo-600 rounded-md transition-colors disabled:bg-gray-700 disabled:text-gray-600 disabled:cursor-not-allowed", title: t('splitLineTooltip') },
                CE(ScissorsIcon, { className: "w-4 h-4" }),
                t('splitLine')
              )
            )
          )
        );
      };
      
      // ** components/ContextMenu.tsx **
      const ContextMenu = ({ x, y, entry, isFirst, isLast, onClose, onMove, onInsert, onMerge, onDelete, t }) => {
          const menuRef = useRef(null);
          const [position, setPosition] = useState({ top: y, left: x });
          useLayoutEffect(() => {
              if (menuRef.current) {
                  const { innerHeight } = window;
                  const { offsetHeight } = menuRef.current;
                  let finalTop = y;
                  if (y + offsetHeight > innerHeight) finalTop = y - offsetHeight;
                  if (finalTop < 0) finalTop = 5;
                  setPosition({ top: finalTop, left: x });
              }
          }, [x, y]);
          useEffect(() => {
              const handleClickOutside = (event) => {
                  if (menuRef.current && !menuRef.current.contains(event.target)) onClose();
              };
              setTimeout(() => { document.addEventListener('click', handleClickOutside); }, 0);
              return () => { document.removeEventListener('click', handleClickOutside); };
          }, [onClose]);
          const handleAction = (action) => {
              action();
              onClose();
          };
          const MenuItem = ({ label, icon, onClick, disabled = false, className = '' }) => CE('button', { onClick: disabled ? undefined : () => handleAction(onClick), disabled, className: `w-full flex items-center px-4 py-2 text-sm text-left transition-colors duration-150 ${disabled ? 'text-gray-600 cursor-not-allowed' : 'text-gray-200 hover:bg-gray-700'} ${className}` },
              CE('span', { className: "mr-3" }, icon),
              label
          );
          return CE('div', { ref: menuRef, style: { position: 'fixed', top: position.top, left: position.left, zIndex: 50 }, className: "w-56 bg-gray-800 border border-gray-700 rounded-md shadow-lg py-1" },
              CE(MenuItem, { label: t('moveUp'), icon: CE(ArrowUpIcon, { className: "w-4 h-4" }), onClick: () => onMove(entry.index, 'up'), disabled: isFirst }),
              CE(MenuItem, { label: t('moveDown'), icon: CE(ArrowDownIcon, { className: "w-4 h-4" }), onClick: () => onMove(entry.index, 'down'), disabled: isLast }),
              CE('div', { className: "border-t border-gray-700 my-1" }),
              CE(MenuItem, { label: t('insertLineBelow'), icon: CE(PlusIcon, { className: "w-4 h-4" }), onClick: () => onInsert(entry.index) }),
              CE(MenuItem, { label: t('mergeWithNext'), icon: CE(ChevronDoubleDownIcon, { className: "w-4 h-4" }), onClick: () => onMerge(entry.index), disabled: isLast }),
              CE('div', { className: "border-t border-gray-700 my-1" }),
              CE(MenuItem, { label: t('delete'), icon: CE(TrashIcon, { className: "w-4 h-4" }), onClick: () => onDelete(entry.index), className: "text-red-400 hover:bg-red-800/50" })
          );
      };

      // ** components/SrtDisplay.tsx **
      const SrtDisplay = ({ entries, setEntries, isRefining, onSetTimeToCurrent, currentTime, onEntryClick, activeIndex, setActiveIndex, t }) => {
        const [contextMenu, setContextMenu] = useState(null);
        const [draggedIndex, setDraggedIndex] = useState(null);
        const [dragOverIndex, setDragOverIndex] = useState(null);
        const scrollContainerRef = useRef(null);
        const listContainerRef = useRef(null);
        const previousCurrentIndexRef = useRef(null);
        const usePrevious = (value) => {
          const ref = useRef();
          useEffect(() => { ref.current = value; }, [value]);
          return ref.current;
        };
        const prevEntriesLength = usePrevious(entries.length);
        const justInsertedInMiddleRef = useRef(false);

        useEffect(() => {
          const currentTimeMs = currentTime * 1000;
          const currentIndex = entries.findIndex(entry => {
              const startTimeMs = timestampToMs(entry.startTime);
              const endTimeMs = timestampToMs(entry.endTime);
              return currentTimeMs >= startTimeMs && currentTimeMs < endTimeMs;
          });
          if (currentIndex !== -1 && currentIndex !== previousCurrentIndexRef.current) {
            const list = listContainerRef.current;
            if (list && list.children[currentIndex]) {
              list.children[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }
          previousCurrentIndexRef.current = currentIndex;
        }, [currentTime, entries]);

        useEffect(() => {
            if (justInsertedInMiddleRef.current) {
                justInsertedInMiddleRef.current = false;
                return;
            }
            if (prevEntriesLength !== undefined && entries.length > prevEntriesLength) {
                const container = scrollContainerRef.current;
                if (container) container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
            }
        }, [entries.length, prevEntriesLength]);

        const handleUpdate = (index, field, value) => {
          setEntries(currentEntries =>
            currentEntries.map(entry =>
              entry.index === index ? { ...entry, [field]: value } : entry
            )
          );
        };
        const handleDelete = useCallback((index) => {
          setEntries(currentEntries =>
            currentEntries.filter(e => e.index !== index).map((e, i) => ({ ...e, index: i + 1 }))
          );
        }, [setEntries]);
        const handleMove = useCallback((originalIndex, direction) => {
          setEntries(currentEntries => {
            const arrayIndex = currentEntries.findIndex(e => e.index === originalIndex);
            if (arrayIndex === -1) return currentEntries;
            const newEntries = [...currentEntries];
            const targetIndex = direction === 'up' ? arrayIndex - 1 : arrayIndex + 1;
            if (targetIndex >= 0 && targetIndex < newEntries.length) {
              [newEntries[arrayIndex], newEntries[targetIndex]] = [newEntries[targetIndex], newEntries[arrayIndex]];
              return newEntries.map((e, i) => ({ ...e, index: i + 1 }));
            }
            return currentEntries;
          });
        }, [setEntries]);
        const handleInsert = useCallback((afterIndex) => {
          justInsertedInMiddleRef.current = true;
          setEntries(currentEntries => {
            const insertAtIndex = currentEntries.findIndex(e => e.index === afterIndex);
            if (insertAtIndex === -1) return currentEntries;
            const previousEntry = currentEntries[insertAtIndex];
            const newEntry = { index: 0, startTime: previousEntry.endTime, endTime: previousEntry.endTime, text: 'New subtitle' };
            const newEntries = [...currentEntries];
            newEntries.splice(insertAtIndex + 1, 0, newEntry);
            return newEntries.map((e, i) => ({ ...e, index: i + 1 }));
          });
        }, [setEntries]);
        const handleMerge = useCallback((indexToMerge) => {
          setEntries(currentEntries => {
            const mergeArrayIndex = currentEntries.findIndex(e => e.index === indexToMerge);
            if (mergeArrayIndex === -1 || mergeArrayIndex >= currentEntries.length - 1) return currentEntries;
            const entry1 = currentEntries[mergeArrayIndex];
            const entry2 = currentEntries[mergeArrayIndex + 1];
            const mergedEntry = { ...entry1, endTime: entry2.endTime, text: `${entry1.text}\n${entry2.text}`.trim() };
            const newEntries = [...currentEntries];
            newEntries[mergeArrayIndex] = mergedEntry;
            newEntries.splice(mergeArrayIndex + 1, 1);
            return newEntries.map((e, i) => ({ ...e, index: i + 1 }));
          });
        }, [setEntries]);
        const handleSplit = useCallback((indexToSplit, splitAt) => {
          justInsertedInMiddleRef.current = true;
          setEntries(currentEntries => {
            const arrayIndex = currentEntries.findIndex(e => e.index === indexToSplit);
            if (arrayIndex === -1) return currentEntries;
            const originalEntry = currentEntries[arrayIndex];
            const originalText = originalEntry.text;
            if (splitAt <= 0 || splitAt >= originalText.length) return currentEntries;
            const text1 = originalText.substring(0, splitAt).trim();
            const text2 = originalText.substring(splitAt).trim();
            if (!text1 || !text2) return currentEntries;
            const startTimeMs = timestampToMs(originalEntry.startTime);
            const endTimeMs = timestampToMs(originalEntry.endTime);
            const durationMs = endTimeMs - startTimeMs;
            let splitTimeMs = startTimeMs;
            if (durationMs > 0) {
              splitTimeMs = startTimeMs + Math.round(durationMs * (splitAt / originalText.length));
            }
            const updatedOriginalEntry = { ...originalEntry, endTime: msToTimestamp(splitTimeMs), text: text1 };
            const newEntry = { index: 0, startTime: msToTimestamp(splitTimeMs), endTime: originalEntry.endTime, text: text2 };
            const newEntries = [...currentEntries];
            newEntries.splice(arrayIndex + 1, 0, newEntry);
            newEntries[arrayIndex] = updatedOriginalEntry;
            return newEntries.map((e, i) => ({ ...e, index: i + 1 }));
          });
        }, [setEntries]);
        const handleContextMenu = (e, entry, isFirst, isLast) => {
          e.preventDefault();
          setContextMenu({ x: e.clientX, y: e.clientY, entry, isFirst, isLast });
        };
        const closeContextMenu = () => setContextMenu(null);
        const handleDragStart = (e, index) => {
          setDraggedIndex(index);
          e.dataTransfer.effectAllowed = 'move';
        };
        const handleDragOver = (e, index) => {
          e.preventDefault();
          if (draggedIndex === null || draggedIndex === index) return;
          setDragOverIndex(index);
        };
        const handleDrop = (e, dropIndex) => {
          e.preventDefault();
          if (draggedIndex === null) return;
          setEntries(currentEntries => {
            const newEntries = [...currentEntries];
            const [draggedItem] = newEntries.splice(draggedIndex, 1);
            newEntries.splice(dropIndex, 0, draggedItem);
            return newEntries.map((entry, i) => ({ ...entry, index: i + 1 }));
          });
        };
        const handleDragEnd = () => {
          setDraggedIndex(null);
          setDragOverIndex(null);
        };

        const allControlsDisabled = isRefining;

        return CE('div', { className: "absolute inset-0 flex flex-col", onClick: contextMenu ? closeContextMenu : undefined },
          isRefining && CE('div', { className: "absolute inset-0 z-30 rounded-lg" }, CE(Loader, { message: t('loadingRefining'), t })),
          contextMenu && CE(ContextMenu, { x: contextMenu.x, y: contextMenu.y, entry: contextMenu.entry, isFirst: contextMenu.isFirst, isLast: contextMenu.isLast, onClose: closeContextMenu, onDelete: handleDelete, onInsert: handleInsert, onMerge: handleMerge, onMove: handleMove, t }),
          CE('div', { ref: scrollContainerRef, className: `p-2 transition-all flex-grow min-h-0 overflow-y-auto ${allControlsDisabled ? 'filter blur-sm pointer-events-none' : ''}`, onClick: () => setActiveIndex(null) },
            CE('div', { className: "space-y-2", ref: listContainerRef },
              entries.map((entry, idx) => {
                const currentTimeMs = currentTime * 1000;
                const startTimeMs = timestampToMs(entry.startTime);
                const endTimeMs = timestampToMs(entry.endTime);
                const isCurrent = currentTimeMs >= startTimeMs && currentTimeMs < endTimeMs;
                return CE(SrtEntry, {
                  key: entry.index,
                  entry: entry,
                  isFirst: idx === 0,
                  isLast: idx === entries.length - 1,
                  onUpdate: handleUpdate,
                  onSetTimeToCurrent: onSetTimeToCurrent,
                  onContextMenu: (e) => handleContextMenu(e, entry, idx === 0, idx === entries.length - 1),
                  onSplit: handleSplit,
                  isActive: activeIndex === entry.index,
                  isCurrent: isCurrent,
                  onClick: (e) => { e.stopPropagation(); onEntryClick(entry); },
                  index: idx,
                  isDragging: draggedIndex === idx,
                  isDragOver: dragOverIndex === idx,
                  onDragStart: handleDragStart,
                  onDragOver: handleDragOver,
                  onDrop: handleDrop,
                  onDragEnd: handleDragEnd,
                  t: t
                });
              })
            )
          )
        );
      };

      // ** components/InfoIconWithTooltip.tsx **
      const InfoIconWithTooltip = ({ text }) => {
          const tooltipRef = useRef(null);
          const containerRef = useRef(null);

          const handleMouseEnter = () => {
              if (!tooltipRef.current || !containerRef.current) return;

              const tooltip = tooltipRef.current;
              const container = containerRef.current;

              const { top: containerTop } = container.getBoundingClientRect();
              const tooltipHeight = tooltip.offsetHeight;
              
              if (containerTop < tooltipHeight + 8) { // 8px margin
                  tooltip.classList.remove('bottom-full', 'mb-2');
                  tooltip.classList.add('top-full', 'mt-2');
              } else {
                  tooltip.classList.remove('top-full', 'mt-2');
                  tooltip.classList.add('bottom-full', 'mb-2');
              }
          };

          return CE('div', { 
                  ref: containerRef, 
                  className: "relative flex items-center group ml-2",
                  onMouseEnter: handleMouseEnter
              },
              CE(InformationCircleIcon, { className: "w-5 h-5 text-gray-400 hover:text-gray-300 cursor-help transition-colors" }),
              CE('div', {
                  ref: tooltipRef,
                  className: "absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-72 p-3 text-sm text-left text-gray-200 bg-gray-800 border border-gray-600 rounded-lg shadow-xl opacity-0 group-hover:opacity-100 transition-all duration-300 pointer-events-none z-50",
                  role: "tooltip"
              }, text)
          );
      };

      // ** App.tsx **
      const useHistoryState = (initialState) => {
          const [history, setHistory] = useState([initialState]);
          const [currentIndex, setCurrentIndex] = useState(0);
          const state = history[currentIndex];
          const setState = useCallback((newState) => {
              const nextState = typeof newState === 'function' ? newState(state) : newState;
              if (JSON.stringify(nextState) === JSON.stringify(state)) return;
              const newHistory = history.slice(0, currentIndex + 1);
              newHistory.push(nextState);
              setHistory(newHistory);
              setCurrentIndex(newHistory.length - 1);
          }, [history, currentIndex, state]);
          const undo = useCallback(() => {
              if (currentIndex > 0) setCurrentIndex(currentIndex - 1);
          }, [currentIndex]);
          const redo = useCallback(() => {
              if (currentIndex < history.length - 1) setCurrentIndex(currentIndex + 1); // Fix: was currentIndex - 1
          }, [currentIndex, history.length]);
          const resetState = useCallback((newState) => {
              setHistory([newState]);
              setCurrentIndex(0);
          }, []);
          const canUndo = currentIndex > 0;
          const canRedo = currentIndex < history.length - 1;
          return { state, setState, undo, redo, canUndo, canRedo, resetState };
      };

      const MAX_FILE_SIZE_MB = 15;
      const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
      
      const App = () => {
        const [videoFile, setVideoFile] = useState(null);
        const [videoUrl, setVideoUrl] = useState(null);
        const [textInput, setTextInput] = useState('');
        const { state: srtEntries, setState: setSrtEntries, resetState: resetSrtEntries, undo, redo, canUndo, canRedo } = useHistoryState([]);
        const [offset, setOffset] = useState(0);
        const [endTimePadding, setEndTimePadding] = useState(0);
        const [activeProcess, setActiveProcess] = useState(null);
        const [loadingMessage, setLoadingMessage] = useState('');
        const [isRefining, setIsRefining] = useState(false);
        const [isTranslating, setIsTranslating] = useState(false);
        const [isImporting, setIsImporting] = useState(false);
        const [targetLanguage, setTargetLanguage] = useState('English');
        const [error, setError] = useState(null);
        const [draftToRestore, setDraftToRestore] = useState(null);
        const [isDownloadMenuOpen, setIsDownloadMenuOpen] = useState(false);
        const [currentTime, setCurrentTime] = useState(0);
        const [activeIndex, setActiveIndex] = useState(null);
        const [importedFileName, setImportedFileName] = useState(null);
        const [language, setLanguage] = useState(getInitialLang);
        const [contentLanguage, setContentLanguage] = useState(language);
        const [detectedFormat, setDetectedFormat] = useState(null);
        
        const isSafari = typeof navigator !== 'undefined' && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

        const t = useCallback((key, replacements = {}) => {
          let text = translations[language]?.[key] || translations.en[key] || key;
          Object.entries(replacements).forEach(([k, v]) => {
              text = text.replace(`{${k}}`, String(v));
          });
          return text;
        }, [language]);
        
        const handlePaste = useCallback(async () => {
          try {
              const text = await navigator.clipboard.readText();
              if (text) {
                  setTextInput(text);
              }
          } catch (err) {
              console.error('Failed to paste from clipboard:', err);
              alert(t('errorPasteBlocked'));
          }
        }, [t]);

        const videoRef = useRef(null);
        const downloadMenuRef = useRef(null);
        const subtitleInputRef = useRef(null);
        const isLoading = activeProcess !== null;

        const handleApiError = useCallback((e, fallbackMessageKey = 'errorFailedToProcess') => {
            console.error(e);
            if (e instanceof Error && e.message === API_KEY_MISSING_ERROR) {
                setError(t('errorApiKeyMissing'));
            } else {
                const errorMessage = e instanceof Error ? e.message : t('errorGeneric');
                setError(t(fallbackMessageKey, {error: errorMessage}));
            }
        }, [t]);
        
        useEffect(() => {
            document.documentElement.lang = language;
        }, [language]);

        useEffect(() => {
          try {
            const savedDraftJSON = localStorage.getItem('srtLyricSyncDraft');
            if (savedDraftJSON) {
              const savedDraft = JSON.parse(savedDraftJSON);
              if (savedDraft.entries && Array.isArray(savedDraft.entries) && savedDraft.entries.length > 0 && savedDraft.fileInfo) {
                if (typeof savedDraft.offset === 'undefined') savedDraft.offset = 0;
                if (typeof savedDraft.endTimePadding === 'undefined') savedDraft.endTimePadding = 0;
                setDraftToRestore(savedDraft);
              }
            }
          } catch (e) {
            console.error("Failed to load or parse draft from localStorage", e);
            localStorage.removeItem('srtLyricSyncDraft');
          }
        }, []);

        useEffect(() => {
          if (isLoading || isRefining) return;
          const handler = setTimeout(() => {
            if (srtEntries.length > 0 && videoFile) {
              const fileInfo = {
                name: videoFile.name,
                size: videoFile.size,
                lastModified: videoFile.lastModified
              };
              const draft = { entries: srtEntries, fileInfo, timestamp: new Date().toISOString(), offset: offset, endTimePadding: endTimePadding };
              localStorage.setItem('srtLyricSyncDraft', JSON.stringify(draft));
            } else if (srtEntries.length === 0) {
              localStorage.removeItem('srtLyricSyncDraft');
            }
          }, 1500);
          return () => clearTimeout(handler);
        }, [srtEntries, videoFile, isLoading, isRefining, offset, endTimePadding]);

        useEffect(() => {
          if (!videoFile) {
            if (videoUrl) URL.revokeObjectURL(videoUrl);
            setVideoUrl(null);
            return;
          }
          const objectUrl = URL.createObjectURL(videoFile);
          setVideoUrl(objectUrl);
          return () => URL.revokeObjectURL(objectUrl);
        }, [videoFile]);
        
        useEffect(() => {
            const trimmedText = textInput.trim();
            if (trimmedText.length < 15) {
                setDetectedFormat(null);
                return;
            }
            if (/^\d+\r?\n\d{2}:\d{2}:\d{2},\d{3}\s*-->\s*\d{2}:\d{2}:\d{2},\d{3}/m.test(trimmedText)) {
                setDetectedFormat('srt');
            } else if (/^WEBVTT/m.test(trimmedText)) {
                setDetectedFormat('vtt');
            } else if (/^\[\d{2}:\d{2}\.\d{2,3}\]/m.test(trimmedText)) {
                setDetectedFormat('lrc');
            } else {
                setDetectedFormat(null);
            }
        }, [textInput]);

        useEffect(() => {
          const handleKeyDown = (event) => {
            if (!videoRef.current || isLoading || isRefining) return;
            const activeElement = document.activeElement;
            const isTyping = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable);
            if (event.code === 'Space' && !isTyping) {
              event.preventDefault();
              if (videoRef.current.paused) videoRef.current.play();
              else videoRef.current.pause();
            }
          };
          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, [isLoading, isRefining]);

        useEffect(() => {
          const handleClickOutside = (event) => {
            if (downloadMenuRef.current && !downloadMenuRef.current.contains(event.target)) setIsDownloadMenuOpen(false);
          };
          document.addEventListener("mousedown", handleClickOutside);
          return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [downloadMenuRef]);

        const handleTranscribe = useCallback(async () => {
          if (!videoFile) {
            setError(t('errorMediaNeededForTranscribe'));
            return;
          }
          setActiveProcess('transcribe');
          setError(null);
          resetSrtEntries([]);
          setOffset(0);
          setEndTimePadding(0);
          setImportedFileName(null);
          setContentLanguage(language);
          try {
            setLoadingMessage(t('loadingTranscribingStep1'));
            const videoBase64 = await fileToBase64(videoFile);
            const transcribedText = await transcribeAudio(videoBase64, videoFile.type);
            setTextInput(transcribedText);
            const detectedLang = await detectLanguage(transcribedText);
            if (detectedLang) {
                setContentLanguage(detectedLang);
            }
            setLoadingMessage(t('loadingTranscribingStep2'));
            const initialSrtData = await generateSrtFromVideoAndText(videoBase64, videoFile.type, transcribedText);
            setLoadingMessage(t('loadingTranscribingStep3'));
            const refinedSrtData = await refineSrtTimings(videoBase64, videoFile.type, initialSrtData);
            resetSrtEntries(refinedSrtData);
            const updatedText = refinedSrtData.map(entry => entry.text).join('\n');
            setTextInput(updatedText);
          } catch (e) {
            handleApiError(e);
          } finally {
            setActiveProcess(null);
            setLoadingMessage('');
          }
        }, [videoFile, resetSrtEntries, setTextInput, t, language, handleApiError]);

        const handleFileSelect = useCallback((file) => {
          if (!file) {
            setVideoFile(null);
            return;
          }
          if (file.size > MAX_FILE_SIZE_BYTES) {
            setError(t('errorFileTooLarge', {size: MAX_FILE_SIZE_MB}));
            setVideoFile(null);
            return;
          }
           if (draftToRestore && (file.name !== draftToRestore.fileInfo.name || file.size !== draftToRestore.fileInfo.size || file.lastModified !== draftToRestore.fileInfo.lastModified)) {
                handleDismissDraft();
           }
          setError(null);
          setVideoFile(file);
        }, [t, draftToRestore]);

        const handleGenerateSrt = useCallback(async (textToGenerate) => {
          if (!videoFile) {
            setError(t('errorMediaNeededForGenerate'));
            return;
          }
          if (!textToGenerate.trim()) {
            setError(t('errorLyricsNeededForGenerate'));
            return;
          }
          setActiveProcess('generate');
          setError(null);
          resetSrtEntries([]);
          setOffset(0);
          setEndTimePadding(0);
          try {
            const detectedLang = await detectLanguage(textToGenerate);
            setContentLanguage(detectedLang || language);
            setLoadingMessage(t('loadingGeneratingStep1'));
            const videoBase64 = await fileToBase64(videoFile);
            const initialSrtData = await generateSrtFromVideoAndText(videoBase64, videoFile.type, textToGenerate);
            setLoadingMessage(t('loadingGeneratingStep2'));
            const refinedSrtData = await refineSrtTimings(videoBase64, videoFile.type, initialSrtData);
            resetSrtEntries(refinedSrtData);
            const updatedText = refinedSrtData.map(entry => entry.text).join('\n');
            setTextInput(updatedText);
          } catch (e) {
            handleApiError(e);
          } finally {
            setActiveProcess(null);
            setLoadingMessage('');
          }
        }, [videoFile, resetSrtEntries, setTextInput, t, language, handleApiError]);

        const handleGenerate = useCallback(() => {
          setImportedFileName(null);
          handleGenerateSrt(textInput);
        }, [textInput, handleGenerateSrt]);

        const handleRefineTimings = useCallback(async () => {
          if (!videoFile) {
            setError(t('errorMediaNeededForRefine'));
            return;
          }
          if (srtEntries.length === 0) {
            setError(t('errorNoSubtitlesToRefine'));
            return;
          }
          setIsRefining(true);
          setError(null);
          try {
            const videoBase64 = await fileToBase64(videoFile);
            const refinedSrtData = await refineSrtTimings(videoBase64, videoFile.type, srtEntries);
            setSrtEntries(refinedSrtData);
            setOffset(0);
            setEndTimePadding(0);
          } catch (e) {
            handleApiError(e);
          } finally {
            setIsRefining(false);
          }
        }, [videoFile, srtEntries, setSrtEntries, t, handleApiError]);

        const languageNameToCodeMap = {
            'English': 'en', 'Spanish': 'es', 'French': 'fr', 'German': 'de', 
            'Italian': 'it', 'Portuguese': 'pt', 'Dutch': 'nl', 'Russian': 'ru', 
            'Chinese (Simplified)': 'zh-CN', 'Japanese': 'ja', 'Korean': 'ko', 
            'Arabic': 'ar', 'Hindi': 'hi'
        };

        const handleTranslate = useCallback(async () => {
          if (srtEntries.length === 0) {
            setError(t('errorNoSubtitlesToTranslate'));
            return;
          }
          setIsTranslating(true);
          setError(null);
          try {
            const translatedSrtData = await translateSrtText(srtEntries, targetLanguage);
            setSrtEntries(translatedSrtData);
            const langCode = languageNameToCodeMap[targetLanguage] || 'en';
            setContentLanguage(langCode);
          } catch (e) {
            handleApiError(e);
          } finally {
            setIsTranslating(false);
          }
        }, [srtEntries, targetLanguage, setSrtEntries, t, handleApiError]);

        const handleOffsetChange = (newOffsetValue) => {
          const diff = newOffsetValue - offset;
          if (diff === 0) return;
          setSrtEntries(currentEntries => currentEntries.map(entry => {
            const newStartTime = timestampToMs(entry.startTime) + diff;
            const newEndTime = timestampToMs(entry.endTime) + diff;
            return { ...entry, startTime: msToTimestamp(newStartTime), endTime: msToTimestamp(newEndTime) };
          }));
          setOffset(newOffsetValue);
        };
        const handleEndTimePaddingChange = (newPadding) => {
          const diff = newPadding - endTimePadding;
          if (diff === 0) return;
          setSrtEntries(currentEntries => currentEntries.map((entry, index) => {
            const startTimeMs = timestampToMs(entry.startTime);
            let newEndTimeMs = timestampToMs(entry.endTime) + diff;
            newEndTimeMs = Math.max(startTimeMs, newEndTimeMs);
            const isIncreasingPadding = diff > 0;
            const hasNextEntry = index < currentEntries.length - 1;
            if (isIncreasingPadding && hasNextEntry) {
              const nextEntryStartTimeMs = timestampToMs(currentEntries[index + 1].startTime);
              newEndTimeMs = Math.min(newEndTimeMs, nextEntryStartTimeMs);
            }
            return { ...entry, endTime: msToTimestamp(newEndTimeMs) };
          }));
          setEndTimePadding(newPadding);
        };
        const handleSetTimeToCurrent = (entryIndex, field) => {
          if (!videoRef.current) return;
          const currentTimeMs = videoRef.current.currentTime * 1000;
          setSrtEntries(currentEntries => {
            const entryArrayIndex = currentEntries.findIndex(e => e.index === entryIndex);
            if (entryArrayIndex === -1) return currentEntries;
            const newEntries = [...currentEntries];
            const entryToUpdate = newEntries[entryArrayIndex];
            if (field === 'startTime') {
              const durationMs = Math.max(0, timestampToMs(entryToUpdate.endTime) - timestampToMs(entryToUpdate.startTime));
              let newStartTimeMs = currentTimeMs;
              if (entryArrayIndex > 0) newStartTimeMs = Math.max(newStartTimeMs, timestampToMs(newEntries[entryArrayIndex - 1].endTime));
              let newEndTimeMs = newStartTimeMs + durationMs;
              if (entryArrayIndex < newEntries.length - 1) {
                const nextEntryStartTimeMs = timestampToMs(newEntries[entryArrayIndex + 1].startTime);
                newEndTimeMs = Math.min(newEndTimeMs, nextEntryStartTimeMs);
                if (newStartTimeMs > newEndTimeMs) newStartTimeMs = newEndTimeMs;
              }
              newEntries[entryArrayIndex] = { ...entryToUpdate, startTime: msToTimestamp(newStartTimeMs), endTime: msToTimestamp(newEndTimeMs) };
            } else {
              let newEndTimeMs = currentTimeMs;
              const currentStartTimeMs = timestampToMs(entryToUpdate.startTime);
              newEndTimeMs = Math.max(newEndTimeMs, currentStartTimeMs);
              if (entryArrayIndex < newEntries.length - 1) {
                const nextEntryStartTimeMs = timestampToMs(newEntries[entryArrayIndex + 1].startTime);
                newEndTimeMs = Math.min(newEndTimeMs, nextEntryStartTimeMs);
              }
              newEntries[entryArrayIndex] = { ...entryToUpdate, endTime: msToTimestamp(newEndTimeMs) };
            }
            return newEntries;
          });
        };
        const handleEntryClick = (entry) => {
          if (videoRef.current) {
            const wasPaused = videoRef.current.paused;
            const seekTime = timestampToMs(entry.startTime) / 1000;
            videoRef.current.currentTime = seekTime;
            if (!wasPaused) {
              videoRef.current.play();
            } else {
              videoRef.current.pause();
            }
          }
          setActiveIndex(entry.index);
        };
        const handleRestoreDraft = () => {
          if (draftToRestore) {
            resetSrtEntries(draftToRestore.entries);
            setOffset(draftToRestore.offset || 0);
            setEndTimePadding(draftToRestore.endTimePadding || 0);
            setImportedFileName(null);
            setContentLanguage(language);
            setError(t('draftRestored'));
            setTimeout(() => setError(null), 6000);
          }
          setDraftToRestore(null);
        };
        const handleDismissDraft = () => {
          localStorage.removeItem('srtLyricSyncDraft');
          setDraftToRestore(null);
        };
        const handleClearSession = () => {
            if (window.confirm(t('clearSessionConfirm'))) {
                setVideoFile(null);
                setTextInput('');
                resetSrtEntries([]);
                setOffset(0);
                setEndTimePadding(0);
                setError(null);
                setActiveProcess(null);
                setImportedFileName(null);
                setDraftToRestore(null);
                setIsDownloadMenuOpen(false);
                setActiveIndex(null);
                setDetectedFormat(null);
                localStorage.removeItem('srtLyricSyncDraft');
            }
        };
        const handleImportSubtitles = (file) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const content = e.target?.result;
                if (!content) {
                    setError(t('errorFileEmpty'));
                    return;
                }
                const extension = file.name.split('.').pop()?.toLowerCase();
                if (extension === 'txt' && videoFile) {
                    setTextInput(content);
                    setImportedFileName(file.name);
                    handleGenerateSrt(content);
                    return;
                }
                setIsImporting(true);
                try {
                    let parsedEntries = [];
                    let fullText = content;
                    if (extension === 'txt') {
                    } else {
                        switch (extension) {
                            case 'srt': parsedEntries = parseSrt(content); break;
                            case 'vtt': parsedEntries = parseVtt(content); break;
                            case 'lrc': parsedEntries = parseLrc(content); break;
                            default:
                                setError(t('errorUnsupportedFileType', { extension }));
                                return;
                        }
                        if (parsedEntries.length === 0) {
                            setError(t('errorNoEntriesFound'));
                            return;
                        }
                        fullText = parsedEntries.map(entry => entry.text).join('\n');
                    }
                    const detectedLang = await detectLanguage(fullText);
                    setContentLanguage(detectedLang || language);
                    setError(null);
                    setTextInput(fullText);
                    resetSrtEntries(parsedEntries);
                    setOffset(0);
                    setEndTimePadding(0);
                    setImportedFileName(file.name);
                } catch (err) {
                    handleApiError(err, 'errorFailedToParseFile');
                    setImportedFileName(null);
                } finally {
                    setIsImporting(false);
                }
            };
            reader.onerror = () => {
                setError('Error reading the file.');
                setImportedFileName(null);
            };
            reader.readAsText(file);
        };
        const handleImportClick = () => subtitleInputRef.current?.click();
        const handleSubtitleFileChange = (e) => {
          if (e.target.files && e.target.files[0]) {
            handleImportSubtitles(e.target.files[0]);
            e.target.value = '';
          }
        };
        const handleParseFromLyrics = async () => {
            if (!detectedFormat) return;
            try {
                let parsedEntries = [];
                switch (detectedFormat) {
                    case 'srt': parsedEntries = parseSrt(textInput); break;
                    case 'vtt': parsedEntries = parseVtt(textInput); break;
                    case 'lrc': parsedEntries = parseLrc(textInput); break;
                    default: return;
                }
                if (parsedEntries.length === 0) {
                    setError(t('errorNoEntriesFound'));
                    return;
                }
                const fullText = parsedEntries.map(entry => entry.text).join('\n');
                const detectedLang = await detectLanguage(fullText);
                setContentLanguage(detectedLang || language);
                setError(null);
                setTextInput(fullText);
                resetSrtEntries(parsedEntries);
                setOffset(0);
                setEndTimePadding(0);
                setImportedFileName(null);
                setDetectedFormat(null);
            } catch (err) {
                const errorMessage = err instanceof Error ? err.message : 'Unknown error';
                setError(t('errorFailedToParseFile', { error: errorMessage }));
            }
        };
        const downloadFile = (content, fileName, mimeType) => {
          const bom = '\uFEFF';
          const blob = new Blob([bom + content], { type: `${mimeType};charset=utf-8` });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };
        const handleDownload = (format) => {
          const getBaseName = () => videoFile?.name.substring(0, videoFile.name.lastIndexOf('.')) || importedFileName?.substring(0, importedFileName.lastIndexOf('.')) || 'subtitles';
          const baseName = getBaseName();
          const langCode = contentLanguage.split('-')[0];
          let content = '', fileName = '', mimeType = 'text/plain';
          switch (format) {
            case 'srt': content = serializeSrt(srtEntries); fileName = `${baseName}_${langCode}.srt`; break;
            case 'vtt': content = srtToVtt(serializeSrt(srtEntries)); fileName = `${baseName}_${langCode}.vtt`; mimeType = 'text/vtt'; break;
            case 'lrc': content = serializeLrc(srtEntries); fileName = `${baseName}_${langCode}.lrc`; break;
          }
          downloadFile(content, fileName, mimeType);
          setIsDownloadMenuOpen(false);
        };

        const allControlsDisabled = isRefining || isLoading || isTranslating || isImporting;
        const canGenerate = videoFile !== null && textInput.trim().length > 0 && !allControlsDisabled;
        const canTranscribe = videoFile !== null && !allControlsDisabled;
        const isAudio = videoFile?.type.startsWith('audio/');
        const uploadBoxTitle = videoFile ? (isAudio ? t('previewHeaderAudio') : t('previewHeaderVideo')) : t('uploadHeader');
        const containerClasses = 'bg-gray-900 text-white font-sans flex flex-col min-h-screen';

        return CE('div', { className: containerClasses },
          draftToRestore && videoFile && draftToRestore.fileInfo && (videoFile.name === draftToRestore.fileInfo.name && videoFile.size === draftToRestore.fileInfo.size && videoFile.lastModified === draftToRestore.fileInfo.lastModified) && CE('div', { className: "bg-gray-800 border-b border-teal-800 text-center p-3 flex justify-center items-center gap-4 text-sm shadow-lg flex-shrink-0" },
            CE(ArchiveBoxIcon, { className: "w-6 h-6 text-teal-400 flex-shrink-0" }),
            CE('p', { className: "text-gray-300" }, t('draftFound'), draftToRestore.fileInfo.name && CE('span', { className: "font-semibold text-white" }, t('draftForFile', {fileName: draftToRestore.fileInfo.name})), t('draftQuery')),
            CE('button', { onClick: handleRestoreDraft, className: "px-4 py-1.5 bg-teal-600 hover:bg-teal-500 rounded-md font-semibold transition-colors" }, t('draftRestore')),
            CE('button', { onClick: handleDismissDraft, className: "px-4 py-1.5 hover:bg-gray-700 rounded-md text-gray-400 hover:text-white transition-colors" }, t('draftDismiss'))
          ),
          CE('main', { className: "max-w-7xl mx-auto w-full flex flex-col flex-grow p-4 min-h-0" },
            CE('header', { className: "flex items-center justify-between my-6 flex-shrink-0" },
              CE('div', { className: "flex items-center gap-1" },
                CE('h1', { className: "text-lg md:text-xl font-semibold tracking-tight text-gray-300 flex flex-wrap justify-center items-center gap-x-2 px-2" },
                  CE('span', { className: "font-bold text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-blue-500" }, t('appTitle')),
                  CE('span', { className: "text-xs md:text-sm text-gray-400 font-normal" }, t('appSubtitle'))
                ),
                CE(InfoIconWithTooltip, { text: t('appDescriptionTooltip') })
              ),
              CE('div', { className: 'flex items-center gap-4' },
                CE('select', { 
                    value: language, 
                    onChange: e => setLanguage(e.target.value),
                    className: "bg-gray-800 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 p-2",
                    "aria-label": t('languageSelectorLabel')
                  },
                  supportedLanguages.map(lang => 
                    CE('option', { key: lang.code, value: lang.code }, lang.name)
                  )
                ),
                CE('button', {
                  onClick: handleClearSession,
                  className: "flex items-center gap-2 px-3 py-2 text-sm font-semibold rounded-lg shadow-md transition-colors duration-200 bg-red-800/80 hover:bg-red-700 text-gray-200",
                  title: t('clearSession')
                }, CE(TrashIcon, { className: "w-5 h-5" }), CE('span', { className: 'hidden md:inline' }, t('clearSession')))
              )
            ),
            CE('div', { className: "grid grid-cols-1 lg:grid-cols-5 gap-6 items-stretch flex-grow min-h-0" },
              CE('div', { className: "lg:col-span-2 flex flex-col gap-6" },
                CE('div', { className: "p-5 bg-gray-800/50 rounded-xl shadow-lg border border-gray-700 flex flex-col min-h-0" },
                  CE('div', { className: "flex items-center justify-between mb-4 flex-wrap gap-2" },
                    CE('div', { className: "flex items-center" },
                      CE('h2', { className: "text-lg font-semibold text-gray-200" }, uploadBoxTitle),
                      CE(InfoIconWithTooltip, { text: t('uploadTooltip') })
                    ),
                    videoFile && CE('span', { className: "text-sm text-gray-400 truncate ml-2", title: videoFile.name }, videoFile.name)
                  ),
                  CE(FileUpload, { videoFile, setVideoFile: handleFileSelect, disabled: allControlsDisabled, videoUrl, t })
                ),
                CE('div', { className: "p-5 bg-gray-800/50 rounded-xl shadow-lg border border-gray-700 flex flex-col flex-grow min-h-0" },
                  CE('div', { className: "flex justify-between items-center mb-4 flex-wrap gap-y-2" },
                    CE('div', { className: "flex items-center" },
                       CE('h2', { className: "text-lg font-semibold text-gray-200" }, t('lyricsHeader')),
                       CE(InfoIconWithTooltip, { text: t('lyricsTooltip') })
                    ),
                    CE('div', { className: "flex items-center gap-2" },
                      !isSafari && CE('button', {
                        onClick: handlePaste,
                        disabled: allControlsDisabled,
                        className: "flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold rounded-lg shadow-md transition-colors duration-200 bg-gray-700 hover:bg-gray-600 text-gray-200 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed",
                        title: t('pasteFromClipboard')
                      }, CE(ClipboardPasteIcon, { className: "w-5 h-5" }), t('pasteFromClipboard')),
                      CE('button', {
                        onClick: handleImportClick,
                        disabled: allControlsDisabled,
                        className: "flex items-center justify-center gap-2 px-3 py-2 text-sm font-semibold rounded-lg shadow-md transition-colors duration-200 bg-gray-700 hover:bg-gray-600 text-gray-200 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed",
                        title: t('importTooltip')
                      }, isImporting ? CE('div', { className: "w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin" }) : CE(UploadIcon, { className: "w-5 h-5" }), isImporting ? t('importActive') : t('import')),
                      CE('input', { type: "file", ref: subtitleInputRef, onChange: handleSubtitleFileChange, accept: ".srt,.vtt,.lrc,.txt", className: "hidden", disabled: allControlsDisabled }),
                      CE('button', { onClick: handleTranscribe, disabled: !canTranscribe, className: "flex items-center gap-2 px-3 py-2 text-sm font-semibold rounded-lg shadow-md transition-colors duration-200 bg-gray-700 hover:bg-gray-600 text-gray-200 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed", title: canTranscribe ? t('transcribeTooltip') : t('transcribeDisabledTooltip') }, CE(MicrophoneIcon, { className: "w-5 h-5" }), activeProcess === 'transcribe' ? t('transcribeActive') : t('transcribe')),
                      CE('button', { onClick: handleGenerate, disabled: !canGenerate, className: "flex items-center gap-2 px-4 py-2 text-sm font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out bg-teal-600 hover:bg-teal-500 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed focus:outline-none focus:ring-4 focus:ring-teal-500/50 transform hover:scale-105 disabled:transform-none", title: canGenerate ? t('generateTooltip') : t('generateDisabledTooltip') }, CE(SparklesIcon, { className: "w-5 h-5" }), activeProcess === 'generate' ? t('generateActive') : t('generate'))
                    )
                  ),
                  CE(TextInput, { textInput, setTextInput, disabled: allControlsDisabled, t }),
                  detectedFormat && !allControlsDisabled && CE('div', { className: "mt-3 text-center" },
                    CE('button', {
                        onClick: handleParseFromLyrics,
                        className: "w-full flex items-center justify-center gap-2 px-4 py-2 text-sm font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out bg-indigo-600 hover:bg-indigo-500 focus:outline-none focus:ring-4 focus:ring-indigo-500/50"
                    }, CE(EditIcon, { className: "w-5 h-5" }), t('detectedFormatLoad', { format: detectedFormat.toUpperCase() }))
                  )
                )
              ),
              CE('div', { className: "lg:col-span-3 p-5 bg-gray-800/50 rounded-xl shadow-lg border border-gray-700 flex flex-col gap-4 h-[90vh] lg:h-auto" },
                CE('div', { className: "flex justify-between items-center flex-wrap gap-2" },
                  CE('div', { className: "flex items-center min-w-0" },
                    CE('h2', { className: "text-lg font-semibold text-gray-200 flex-shrink-0" }, t('editorHeader')),
                    CE(InfoIconWithTooltip, { text: t('editorTooltip') }),
                    importedFileName && CE('span', { className: "text-sm text-gray-400 truncate ml-2", title: importedFileName }, importedFileName)
                  ),
                  CE('div', { className: "flex items-center flex-wrap justify-end gap-2" },
                    CE('div', { className: "flex items-center", role: "group" },
                      CE('button', { onClick: undo, disabled: !canUndo || allControlsDisabled, className: "p-2 rounded-l-md bg-gray-700 hover:bg-gray-600 transition-colors text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed", title: t('undo') }, CE(UndoIcon, { className: "w-5 h-5" })),
                      CE('button', { onClick: redo, disabled: !canRedo || allControlsDisabled, className: "p-2 rounded-r-md bg-gray-700 hover:bg-gray-600 border-l border-gray-800 transition-colors text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed", title: t('redo') }, CE(RedoIcon, { className: "w-5 h-5" }))
                    ),
                    CE('div', { className: "flex items-center shadow-md", role: "group" },
                      CE('select', {
                        value: targetLanguage,
                        onChange: e => setTargetLanguage(e.target.value),
                        disabled: allControlsDisabled || srtEntries.length === 0,
                        className: "py-2 pl-3 pr-8 text-sm bg-gray-700 hover:bg-gray-600 rounded-l-md border-r border-gray-800 text-gray-200 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-teal-500 transition-colors disabled:opacity-50 disabled:cursor-not-allowed w-36",
                        "aria-label": t('languageSelectLabelDropdown'),
                        title: t('languageSelectLabelDropdown')
                      },
                        ['English', 'Spanish', 'French', 'German', 'Italian', 'Portuguese', 'Dutch', 'Russian', 'Chinese (Simplified)', 'Japanese', 'Korean', 'Arabic', 'Hindi'].map(lang => CE('option', { key: lang, value: lang }, lang))
                      ),
                      CE('button', {
                        onClick: handleTranslate,
                        disabled: allControlsDisabled || srtEntries.length === 0,
                        className: "flex items-center gap-2 p-2 lg:px-3 text-sm bg-gray-700 hover:bg-gray-600 rounded-r-md transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed",
                        title: t('translateTooltip', {language: targetLanguage})
                      },
                        CE(LanguageIcon, { className: "w-5 h-5" }),
                        CE('span', { className: "hidden lg:inline" }, isTranslating ? t('translateActive') : t('translate'))
                      )
                    ),
                    CE('button', { onClick: handleRefineTimings, disabled: allControlsDisabled || !videoFile || srtEntries.length === 0, className: "flex items-center gap-2 p-2 lg:px-3 text-sm bg-indigo-600 hover:bg-indigo-500 rounded-md transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed", title: t('refineTooltip') }, CE(SparklesIcon, { className: "w-5 h-5" }), CE('span', { className: "hidden lg:inline" }, t('refine'))),
                    CE('div', { className: "relative inline-flex shadow-md", ref: downloadMenuRef },
                      CE('button', { onClick: () => handleDownload('srt'), disabled: srtEntries.length === 0 || allControlsDisabled, className: "flex items-center gap-2 p-2 lg:px-3 text-sm bg-teal-600 hover:bg-teal-500 rounded-l-md transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed", title: t('downloadSRTTooltip') }, CE(DownloadIcon, { className: "w-5 h-5" }), CE('span', { className: "hidden lg:inline" }, t('downloadSRT'))),
                      CE('button', { onClick: () => setIsDownloadMenuOpen(prev => !prev), disabled: srtEntries.length === 0 || allControlsDisabled, className: "p-2 md:px-1.5 bg-teal-600 hover:bg-teal-500 rounded-r-md border-l border-teal-700 transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed", title: t('moreDownloads') }, CE(ChevronDownIcon, { className: "w-5 h-5" })),
                      isDownloadMenuOpen && CE('div', { className: "absolute right-0 top-full mt-2 w-40 bg-gray-700 rounded-md shadow-lg z-10 border border-gray-600 overflow-hidden" },
                        CE('a', { onClick: () => handleDownload('vtt'), className: "block px-4 py-2 text-sm text-gray-200 hover:bg-gray-600 cursor-pointer" }, t('downloadVTT')),
                        CE('a', { onClick: () => handleDownload('lrc'), className: "block px-4 py-2 text-sm text-gray-200 hover:bg-gray-600 cursor-pointer" }, t('downloadLRC'))
                      )
                    )
                  )
                ),
                CE('div', { className: "bg-gray-900/70 rounded-lg relative flex flex-col flex-grow min-h-0" },
                  isLoading && CE(Loader, { message: loadingMessage, t }),
                  !isLoading && error && CE('div', { className: "flex items-center justify-center h-full text-center text-red-400 p-4" }, CE('p', null, error)),
                  !isLoading && !error && srtEntries.length > 0 && videoFile && videoUrl ? CE('div', { className: "grid grid-rows-[auto_auto_1fr] flex-grow min-h-0" },
                    CE('div', { className: "relative bg-black border-b-2 border-gray-700/50 max-h-[25vh] lg:max-h-[35vh] p-2" }, CE(VideoPreview, { ref: videoRef, videoFile, videoUrl, entries: srtEntries, onTimeUpdate: setCurrentTime, t })),
                    CE('div', { className: `p-3 bg-gray-900/50 border-b border-gray-700 transition-all ${allControlsDisabled ? 'filter blur-sm pointer-events-none' : ''}` },
                      CE('div', { className: "grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4" },
                        CE('div', { className: "flex-1 min-w-[280px]" },
                          CE('label', { htmlFor: "timing-offset-slider", className: "block text-sm font-medium text-gray-300 mb-2", title: t('globalOffsetTooltip') }, t('globalOffset')),
                          CE('div', { className: "flex items-center gap-3" },
                            CE('input', { id: "timing-offset-slider", type: "range", min: "-2000", max: "2000", step: "10", value: offset, onChange: (e) => handleOffsetChange(parseInt(e.target.value, 10)), className: "w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50", disabled: allControlsDisabled, title: `${offset}ms` }),
                            CE('input', { type: "number", value: offset, onChange: (e) => handleOffsetChange(parseInt(e.target.value, 10) || 0), className: "w-24 bg-gray-700 text-center p-1 rounded border border-gray-600 disabled:opacity-50", step: "10", "aria-label": "Timing offset in milliseconds", disabled: allControlsDisabled }),
                            CE('button', { onClick: () => handleOffsetChange(0), disabled: offset === 0 || allControlsDisabled, className: "p-2 rounded-md hover:bg-gray-700 transition-colors text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed", title: t('resetOffset') }, CE(ArrowPathIcon, { className: "w-5 h-5" }))
                          )
                        ),
                        CE('div', { className: "flex-1 min-w-[280px]" },
                          CE('label', { htmlFor: "end-time-padding-slider", className: "block text-sm font-medium text-gray-300 mb-2", title: t('vocalDecayTooltip') }, t('vocalDecay')),
                          CE('div', { className: "flex items-center gap-3" },
                            CE('input', { id: "end-time-padding-slider", type: "range", min: "-2000", max: "2000", step: "10", value: endTimePadding, onChange: (e) => handleEndTimePaddingChange(parseInt(e.target.value, 10)), className: "w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50", disabled: allControlsDisabled, title: `${endTimePadding >= 0 ? '+' : ''}${endTimePadding}ms` }),
                            CE('input', { type: "number", value: endTimePadding, onChange: (e) => handleEndTimePaddingChange(parseInt(e.target.value, 10) || 0), className: "w-24 bg-gray-700 text-center p-1 rounded border border-gray-600 disabled:opacity-50", step: "10", "aria-label": "End time padding in milliseconds", disabled: allControlsDisabled }),
                            CE('button', { onClick: () => handleEndTimePaddingChange(0), disabled: endTimePadding === 0 || allControlsDisabled, className: "p-2 rounded-md hover:bg-gray-700 transition-colors text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed", title: t('resetPadding') }, CE(ArrowPathIcon, { className: "w-5 h-5" }))
                          )
                        )
                      )
                    ),
                    CE('div', { className: "min-h-0 relative" }, CE(SrtDisplay, { entries: srtEntries, setEntries: setSrtEntries, isRefining, onSetTimeToCurrent: handleSetTimeToCurrent, currentTime, onEntryClick: handleEntryClick, activeIndex, setActiveIndex, t }))
                  ) : (!isLoading && !error && srtEntries.length === 0 && CE('div', { className: "flex items-center justify-center h-full text-center text-gray-400 p-4" }, CE('p', null, t('placeholder')))),
                  !isLoading && !error && srtEntries.length > 0 && !videoFile && CE('div', { className: "flex flex-col items-center justify-center h-full text-center text-red-400 p-4" }, CE('p', { className: "font-semibold text-lg" }, t('mediaMissing')), CE('p', { className: "mt-2 text-gray-300" }, t('mediaMissingDescription')))
                )
              )
            )
          ),
          CE('footer', { className: "text-center py-4 text-gray-400 text-sm flex-shrink-0" },
            CE('p', null, t('poweredBy'))
          )
        );
      };

      // --- End of inlined files ---

      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(CE(React.StrictMode, null, CE(App)));
    </script>
  </body>
</html>